// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"strconv"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/vmihailenco/msgpack/v5"
	"rei.io/rei/ent/accounts"
	"rei.io/rei/ent/arguments"
	"rei.io/rei/ent/events"
	"rei.io/rei/ent/nfts"
	"rei.io/rei/ent/objects"
	"rei.io/rei/ent/packages"
	"rei.io/rei/ent/sessions"
	"rei.io/rei/ent/transactions"
	"rei.io/rei/ent/users"
)

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

// MarshalGQL implements graphql.Marshaler interface.
func (o OrderDirection) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(o.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (o *OrderDirection) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("order direction %T must be a string", val)
	}
	*o = OrderDirection(str)
	return o.Validate()
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

func (o OrderDirection) orderFunc(field string) OrderFunc {
	if o == OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

func cursorsToPredicates(direction OrderDirection, after, before *Cursor, field, idField string) []func(s *sql.Selector) {
	var predicates []func(s *sql.Selector)
	if after != nil {
		if after.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeGT
			} else {
				predicate = sql.CompositeLT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					after.Value, after.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.GT
			} else {
				predicate = sql.LT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					after.ID,
				))
			})
		}
	}
	if before != nil {
		if before.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeLT
			} else {
				predicate = sql.CompositeGT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					before.Value, before.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.LT
			} else {
				predicate = sql.GT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					before.ID,
				))
			})
		}
	}
	return predicates
}

// PageInfo of a connection type.
type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *Cursor `json:"startCursor"`
	EndCursor       *Cursor `json:"endCursor"`
}

// Cursor of an edge type.
type Cursor struct {
	ID    int   `msgpack:"i"`
	Value Value `msgpack:"v,omitempty"`
}

// MarshalGQL implements graphql.Marshaler interface.
func (c Cursor) MarshalGQL(w io.Writer) {
	quote := []byte{'"'}
	w.Write(quote)
	defer w.Write(quote)
	wc := base64.NewEncoder(base64.RawStdEncoding, w)
	defer wc.Close()
	_ = msgpack.NewEncoder(wc).Encode(c)
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (c *Cursor) UnmarshalGQL(v interface{}) error {
	s, ok := v.(string)
	if !ok {
		return fmt.Errorf("%T is not a string", v)
	}
	if err := msgpack.NewDecoder(
		base64.NewDecoder(
			base64.RawStdEncoding,
			strings.NewReader(s),
		),
	).Decode(c); err != nil {
		return fmt.Errorf("cannot decode cursor: %w", err)
	}
	return nil
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// AccountsEdge is the edge representation of Accounts.
type AccountsEdge struct {
	Node   *Accounts `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// AccountsConnection is the connection containing edges to Accounts.
type AccountsConnection struct {
	Edges      []*AccountsEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *AccountsConnection) build(nodes []*Accounts, pager *accountsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Accounts
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Accounts {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Accounts {
			return nodes[i]
		}
	}
	c.Edges = make([]*AccountsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AccountsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AccountsPaginateOption enables pagination customization.
type AccountsPaginateOption func(*accountsPager) error

// WithAccountsOrder configures pagination ordering.
func WithAccountsOrder(order *AccountsOrder) AccountsPaginateOption {
	if order == nil {
		order = DefaultAccountsOrder
	}
	o := *order
	return func(pager *accountsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAccountsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAccountsFilter configures pagination filter.
func WithAccountsFilter(filter func(*AccountsQuery) (*AccountsQuery, error)) AccountsPaginateOption {
	return func(pager *accountsPager) error {
		if filter == nil {
			return errors.New("AccountsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type accountsPager struct {
	order  *AccountsOrder
	filter func(*AccountsQuery) (*AccountsQuery, error)
}

func newAccountsPager(opts []AccountsPaginateOption) (*accountsPager, error) {
	pager := &accountsPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAccountsOrder
	}
	return pager, nil
}

func (p *accountsPager) applyFilter(query *AccountsQuery) (*AccountsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *accountsPager) toCursor(a *Accounts) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *accountsPager) applyCursors(query *AccountsQuery, after, before *Cursor) *AccountsQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAccountsOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *accountsPager) applyOrder(query *AccountsQuery, reverse bool) *AccountsQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAccountsOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAccountsOrder.Field.field))
	}
	return query
}

func (p *accountsPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAccountsOrder.Field {
			b.Comma().Ident(DefaultAccountsOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Accounts.
func (a *AccountsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AccountsPaginateOption,
) (*AccountsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAccountsPager(opts)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &AccountsConnection{Edges: []*AccountsEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = a.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	a = pager.applyCursors(a, after, before)
	a = pager.applyOrder(a, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// AccountsOrderField defines the ordering field of Accounts.
type AccountsOrderField struct {
	field    string
	toCursor func(*Accounts) Cursor
}

// AccountsOrder defines the ordering of Accounts.
type AccountsOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *AccountsOrderField `json:"field"`
}

// DefaultAccountsOrder is the default ordering of Accounts.
var DefaultAccountsOrder = &AccountsOrder{
	Direction: OrderDirectionAsc,
	Field: &AccountsOrderField{
		field: accounts.FieldID,
		toCursor: func(a *Accounts) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Accounts into AccountsEdge.
func (a *Accounts) ToEdge(order *AccountsOrder) *AccountsEdge {
	if order == nil {
		order = DefaultAccountsOrder
	}
	return &AccountsEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// ArgumentsEdge is the edge representation of Arguments.
type ArgumentsEdge struct {
	Node   *Arguments `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// ArgumentsConnection is the connection containing edges to Arguments.
type ArgumentsConnection struct {
	Edges      []*ArgumentsEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *ArgumentsConnection) build(nodes []*Arguments, pager *argumentsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Arguments
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Arguments {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Arguments {
			return nodes[i]
		}
	}
	c.Edges = make([]*ArgumentsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ArgumentsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ArgumentsPaginateOption enables pagination customization.
type ArgumentsPaginateOption func(*argumentsPager) error

// WithArgumentsOrder configures pagination ordering.
func WithArgumentsOrder(order *ArgumentsOrder) ArgumentsPaginateOption {
	if order == nil {
		order = DefaultArgumentsOrder
	}
	o := *order
	return func(pager *argumentsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultArgumentsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithArgumentsFilter configures pagination filter.
func WithArgumentsFilter(filter func(*ArgumentsQuery) (*ArgumentsQuery, error)) ArgumentsPaginateOption {
	return func(pager *argumentsPager) error {
		if filter == nil {
			return errors.New("ArgumentsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type argumentsPager struct {
	order  *ArgumentsOrder
	filter func(*ArgumentsQuery) (*ArgumentsQuery, error)
}

func newArgumentsPager(opts []ArgumentsPaginateOption) (*argumentsPager, error) {
	pager := &argumentsPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultArgumentsOrder
	}
	return pager, nil
}

func (p *argumentsPager) applyFilter(query *ArgumentsQuery) (*ArgumentsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *argumentsPager) toCursor(a *Arguments) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *argumentsPager) applyCursors(query *ArgumentsQuery, after, before *Cursor) *ArgumentsQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultArgumentsOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *argumentsPager) applyOrder(query *ArgumentsQuery, reverse bool) *ArgumentsQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultArgumentsOrder.Field {
		query = query.Order(direction.orderFunc(DefaultArgumentsOrder.Field.field))
	}
	return query
}

func (p *argumentsPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultArgumentsOrder.Field {
			b.Comma().Ident(DefaultArgumentsOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Arguments.
func (a *ArgumentsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ArgumentsPaginateOption,
) (*ArgumentsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newArgumentsPager(opts)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &ArgumentsConnection{Edges: []*ArgumentsEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = a.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	a = pager.applyCursors(a, after, before)
	a = pager.applyOrder(a, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ArgumentsOrderField defines the ordering field of Arguments.
type ArgumentsOrderField struct {
	field    string
	toCursor func(*Arguments) Cursor
}

// ArgumentsOrder defines the ordering of Arguments.
type ArgumentsOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *ArgumentsOrderField `json:"field"`
}

// DefaultArgumentsOrder is the default ordering of Arguments.
var DefaultArgumentsOrder = &ArgumentsOrder{
	Direction: OrderDirectionAsc,
	Field: &ArgumentsOrderField{
		field: arguments.FieldID,
		toCursor: func(a *Arguments) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Arguments into ArgumentsEdge.
func (a *Arguments) ToEdge(order *ArgumentsOrder) *ArgumentsEdge {
	if order == nil {
		order = DefaultArgumentsOrder
	}
	return &ArgumentsEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// EventsEdge is the edge representation of Events.
type EventsEdge struct {
	Node   *Events `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// EventsConnection is the connection containing edges to Events.
type EventsConnection struct {
	Edges      []*EventsEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *EventsConnection) build(nodes []*Events, pager *eventsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Events
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Events {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Events {
			return nodes[i]
		}
	}
	c.Edges = make([]*EventsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EventsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EventsPaginateOption enables pagination customization.
type EventsPaginateOption func(*eventsPager) error

// WithEventsOrder configures pagination ordering.
func WithEventsOrder(order *EventsOrder) EventsPaginateOption {
	if order == nil {
		order = DefaultEventsOrder
	}
	o := *order
	return func(pager *eventsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEventsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEventsFilter configures pagination filter.
func WithEventsFilter(filter func(*EventsQuery) (*EventsQuery, error)) EventsPaginateOption {
	return func(pager *eventsPager) error {
		if filter == nil {
			return errors.New("EventsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type eventsPager struct {
	order  *EventsOrder
	filter func(*EventsQuery) (*EventsQuery, error)
}

func newEventsPager(opts []EventsPaginateOption) (*eventsPager, error) {
	pager := &eventsPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEventsOrder
	}
	return pager, nil
}

func (p *eventsPager) applyFilter(query *EventsQuery) (*EventsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *eventsPager) toCursor(e *Events) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *eventsPager) applyCursors(query *EventsQuery, after, before *Cursor) *EventsQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEventsOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *eventsPager) applyOrder(query *EventsQuery, reverse bool) *EventsQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEventsOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEventsOrder.Field.field))
	}
	return query
}

func (p *eventsPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEventsOrder.Field {
			b.Comma().Ident(DefaultEventsOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Events.
func (e *EventsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EventsPaginateOption,
) (*EventsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEventsPager(opts)
	if err != nil {
		return nil, err
	}
	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}
	conn := &EventsConnection{Edges: []*EventsEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = e.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	e = pager.applyCursors(e, after, before)
	e = pager.applyOrder(e, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		e.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := e.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// EventsOrderField defines the ordering field of Events.
type EventsOrderField struct {
	field    string
	toCursor func(*Events) Cursor
}

// EventsOrder defines the ordering of Events.
type EventsOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *EventsOrderField `json:"field"`
}

// DefaultEventsOrder is the default ordering of Events.
var DefaultEventsOrder = &EventsOrder{
	Direction: OrderDirectionAsc,
	Field: &EventsOrderField{
		field: events.FieldID,
		toCursor: func(e *Events) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Events into EventsEdge.
func (e *Events) ToEdge(order *EventsOrder) *EventsEdge {
	if order == nil {
		order = DefaultEventsOrder
	}
	return &EventsEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// NFTsEdge is the edge representation of NFTs.
type NFTsEdge struct {
	Node   *NFTs  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// NFTsConnection is the connection containing edges to NFTs.
type NFTsConnection struct {
	Edges      []*NFTsEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *NFTsConnection) build(nodes []*NFTs, pager *nftsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *NFTs
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *NFTs {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *NFTs {
			return nodes[i]
		}
	}
	c.Edges = make([]*NFTsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NFTsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NFTsPaginateOption enables pagination customization.
type NFTsPaginateOption func(*nftsPager) error

// WithNFTsOrder configures pagination ordering.
func WithNFTsOrder(order *NFTsOrder) NFTsPaginateOption {
	if order == nil {
		order = DefaultNFTsOrder
	}
	o := *order
	return func(pager *nftsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNFTsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNFTsFilter configures pagination filter.
func WithNFTsFilter(filter func(*NFTsQuery) (*NFTsQuery, error)) NFTsPaginateOption {
	return func(pager *nftsPager) error {
		if filter == nil {
			return errors.New("NFTsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type nftsPager struct {
	order  *NFTsOrder
	filter func(*NFTsQuery) (*NFTsQuery, error)
}

func newNFTsPager(opts []NFTsPaginateOption) (*nftsPager, error) {
	pager := &nftsPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNFTsOrder
	}
	return pager, nil
}

func (p *nftsPager) applyFilter(query *NFTsQuery) (*NFTsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *nftsPager) toCursor(nt *NFTs) Cursor {
	return p.order.Field.toCursor(nt)
}

func (p *nftsPager) applyCursors(query *NFTsQuery, after, before *Cursor) *NFTsQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultNFTsOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *nftsPager) applyOrder(query *NFTsQuery, reverse bool) *NFTsQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultNFTsOrder.Field {
		query = query.Order(direction.orderFunc(DefaultNFTsOrder.Field.field))
	}
	return query
}

func (p *nftsPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultNFTsOrder.Field {
			b.Comma().Ident(DefaultNFTsOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to NFTs.
func (nt *NFTsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NFTsPaginateOption,
) (*NFTsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNFTsPager(opts)
	if err != nil {
		return nil, err
	}
	if nt, err = pager.applyFilter(nt); err != nil {
		return nil, err
	}
	conn := &NFTsConnection{Edges: []*NFTsEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = nt.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	nt = pager.applyCursors(nt, after, before)
	nt = pager.applyOrder(nt, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		nt.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := nt.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := nt.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// NFTsOrderField defines the ordering field of NFTs.
type NFTsOrderField struct {
	field    string
	toCursor func(*NFTs) Cursor
}

// NFTsOrder defines the ordering of NFTs.
type NFTsOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *NFTsOrderField `json:"field"`
}

// DefaultNFTsOrder is the default ordering of NFTs.
var DefaultNFTsOrder = &NFTsOrder{
	Direction: OrderDirectionAsc,
	Field: &NFTsOrderField{
		field: nfts.FieldID,
		toCursor: func(nt *NFTs) Cursor {
			return Cursor{ID: nt.ID}
		},
	},
}

// ToEdge converts NFTs into NFTsEdge.
func (nt *NFTs) ToEdge(order *NFTsOrder) *NFTsEdge {
	if order == nil {
		order = DefaultNFTsOrder
	}
	return &NFTsEdge{
		Node:   nt,
		Cursor: order.Field.toCursor(nt),
	}
}

// ObjectsEdge is the edge representation of Objects.
type ObjectsEdge struct {
	Node   *Objects `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ObjectsConnection is the connection containing edges to Objects.
type ObjectsConnection struct {
	Edges      []*ObjectsEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ObjectsConnection) build(nodes []*Objects, pager *objectsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Objects
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Objects {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Objects {
			return nodes[i]
		}
	}
	c.Edges = make([]*ObjectsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ObjectsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ObjectsPaginateOption enables pagination customization.
type ObjectsPaginateOption func(*objectsPager) error

// WithObjectsOrder configures pagination ordering.
func WithObjectsOrder(order *ObjectsOrder) ObjectsPaginateOption {
	if order == nil {
		order = DefaultObjectsOrder
	}
	o := *order
	return func(pager *objectsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultObjectsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithObjectsFilter configures pagination filter.
func WithObjectsFilter(filter func(*ObjectsQuery) (*ObjectsQuery, error)) ObjectsPaginateOption {
	return func(pager *objectsPager) error {
		if filter == nil {
			return errors.New("ObjectsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type objectsPager struct {
	order  *ObjectsOrder
	filter func(*ObjectsQuery) (*ObjectsQuery, error)
}

func newObjectsPager(opts []ObjectsPaginateOption) (*objectsPager, error) {
	pager := &objectsPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultObjectsOrder
	}
	return pager, nil
}

func (p *objectsPager) applyFilter(query *ObjectsQuery) (*ObjectsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *objectsPager) toCursor(o *Objects) Cursor {
	return p.order.Field.toCursor(o)
}

func (p *objectsPager) applyCursors(query *ObjectsQuery, after, before *Cursor) *ObjectsQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultObjectsOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *objectsPager) applyOrder(query *ObjectsQuery, reverse bool) *ObjectsQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultObjectsOrder.Field {
		query = query.Order(direction.orderFunc(DefaultObjectsOrder.Field.field))
	}
	return query
}

func (p *objectsPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultObjectsOrder.Field {
			b.Comma().Ident(DefaultObjectsOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Objects.
func (o *ObjectsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ObjectsPaginateOption,
) (*ObjectsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newObjectsPager(opts)
	if err != nil {
		return nil, err
	}
	if o, err = pager.applyFilter(o); err != nil {
		return nil, err
	}
	conn := &ObjectsConnection{Edges: []*ObjectsEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = o.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	o = pager.applyCursors(o, after, before)
	o = pager.applyOrder(o, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		o.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := o.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := o.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ObjectsOrderField defines the ordering field of Objects.
type ObjectsOrderField struct {
	field    string
	toCursor func(*Objects) Cursor
}

// ObjectsOrder defines the ordering of Objects.
type ObjectsOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ObjectsOrderField `json:"field"`
}

// DefaultObjectsOrder is the default ordering of Objects.
var DefaultObjectsOrder = &ObjectsOrder{
	Direction: OrderDirectionAsc,
	Field: &ObjectsOrderField{
		field: objects.FieldID,
		toCursor: func(o *Objects) Cursor {
			return Cursor{ID: o.ID}
		},
	},
}

// ToEdge converts Objects into ObjectsEdge.
func (o *Objects) ToEdge(order *ObjectsOrder) *ObjectsEdge {
	if order == nil {
		order = DefaultObjectsOrder
	}
	return &ObjectsEdge{
		Node:   o,
		Cursor: order.Field.toCursor(o),
	}
}

// PackagesEdge is the edge representation of Packages.
type PackagesEdge struct {
	Node   *Packages `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// PackagesConnection is the connection containing edges to Packages.
type PackagesConnection struct {
	Edges      []*PackagesEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *PackagesConnection) build(nodes []*Packages, pager *packagesPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Packages
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Packages {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Packages {
			return nodes[i]
		}
	}
	c.Edges = make([]*PackagesEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PackagesEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PackagesPaginateOption enables pagination customization.
type PackagesPaginateOption func(*packagesPager) error

// WithPackagesOrder configures pagination ordering.
func WithPackagesOrder(order *PackagesOrder) PackagesPaginateOption {
	if order == nil {
		order = DefaultPackagesOrder
	}
	o := *order
	return func(pager *packagesPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPackagesOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPackagesFilter configures pagination filter.
func WithPackagesFilter(filter func(*PackagesQuery) (*PackagesQuery, error)) PackagesPaginateOption {
	return func(pager *packagesPager) error {
		if filter == nil {
			return errors.New("PackagesQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type packagesPager struct {
	order  *PackagesOrder
	filter func(*PackagesQuery) (*PackagesQuery, error)
}

func newPackagesPager(opts []PackagesPaginateOption) (*packagesPager, error) {
	pager := &packagesPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPackagesOrder
	}
	return pager, nil
}

func (p *packagesPager) applyFilter(query *PackagesQuery) (*PackagesQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *packagesPager) toCursor(pa *Packages) Cursor {
	return p.order.Field.toCursor(pa)
}

func (p *packagesPager) applyCursors(query *PackagesQuery, after, before *Cursor) *PackagesQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultPackagesOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *packagesPager) applyOrder(query *PackagesQuery, reverse bool) *PackagesQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultPackagesOrder.Field {
		query = query.Order(direction.orderFunc(DefaultPackagesOrder.Field.field))
	}
	return query
}

func (p *packagesPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPackagesOrder.Field {
			b.Comma().Ident(DefaultPackagesOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Packages.
func (pa *PackagesQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PackagesPaginateOption,
) (*PackagesConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPackagesPager(opts)
	if err != nil {
		return nil, err
	}
	if pa, err = pager.applyFilter(pa); err != nil {
		return nil, err
	}
	conn := &PackagesConnection{Edges: []*PackagesEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pa.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	pa = pager.applyCursors(pa, after, before)
	pa = pager.applyOrder(pa, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		pa.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pa.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := pa.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PackagesOrderField defines the ordering field of Packages.
type PackagesOrderField struct {
	field    string
	toCursor func(*Packages) Cursor
}

// PackagesOrder defines the ordering of Packages.
type PackagesOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *PackagesOrderField `json:"field"`
}

// DefaultPackagesOrder is the default ordering of Packages.
var DefaultPackagesOrder = &PackagesOrder{
	Direction: OrderDirectionAsc,
	Field: &PackagesOrderField{
		field: packages.FieldID,
		toCursor: func(pa *Packages) Cursor {
			return Cursor{ID: pa.ID}
		},
	},
}

// ToEdge converts Packages into PackagesEdge.
func (pa *Packages) ToEdge(order *PackagesOrder) *PackagesEdge {
	if order == nil {
		order = DefaultPackagesOrder
	}
	return &PackagesEdge{
		Node:   pa,
		Cursor: order.Field.toCursor(pa),
	}
}

// SessionsEdge is the edge representation of Sessions.
type SessionsEdge struct {
	Node   *Sessions `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// SessionsConnection is the connection containing edges to Sessions.
type SessionsConnection struct {
	Edges      []*SessionsEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *SessionsConnection) build(nodes []*Sessions, pager *sessionsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Sessions
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Sessions {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Sessions {
			return nodes[i]
		}
	}
	c.Edges = make([]*SessionsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SessionsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SessionsPaginateOption enables pagination customization.
type SessionsPaginateOption func(*sessionsPager) error

// WithSessionsOrder configures pagination ordering.
func WithSessionsOrder(order *SessionsOrder) SessionsPaginateOption {
	if order == nil {
		order = DefaultSessionsOrder
	}
	o := *order
	return func(pager *sessionsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSessionsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSessionsFilter configures pagination filter.
func WithSessionsFilter(filter func(*SessionsQuery) (*SessionsQuery, error)) SessionsPaginateOption {
	return func(pager *sessionsPager) error {
		if filter == nil {
			return errors.New("SessionsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type sessionsPager struct {
	order  *SessionsOrder
	filter func(*SessionsQuery) (*SessionsQuery, error)
}

func newSessionsPager(opts []SessionsPaginateOption) (*sessionsPager, error) {
	pager := &sessionsPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSessionsOrder
	}
	return pager, nil
}

func (p *sessionsPager) applyFilter(query *SessionsQuery) (*SessionsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *sessionsPager) toCursor(s *Sessions) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *sessionsPager) applyCursors(query *SessionsQuery, after, before *Cursor) *SessionsQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultSessionsOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *sessionsPager) applyOrder(query *SessionsQuery, reverse bool) *SessionsQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultSessionsOrder.Field {
		query = query.Order(direction.orderFunc(DefaultSessionsOrder.Field.field))
	}
	return query
}

func (p *sessionsPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSessionsOrder.Field {
			b.Comma().Ident(DefaultSessionsOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Sessions.
func (s *SessionsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SessionsPaginateOption,
) (*SessionsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSessionsPager(opts)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &SessionsConnection{Edges: []*SessionsEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = s.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	s = pager.applyCursors(s, after, before)
	s = pager.applyOrder(s, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// SessionsOrderField defines the ordering field of Sessions.
type SessionsOrderField struct {
	field    string
	toCursor func(*Sessions) Cursor
}

// SessionsOrder defines the ordering of Sessions.
type SessionsOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *SessionsOrderField `json:"field"`
}

// DefaultSessionsOrder is the default ordering of Sessions.
var DefaultSessionsOrder = &SessionsOrder{
	Direction: OrderDirectionAsc,
	Field: &SessionsOrderField{
		field: sessions.FieldID,
		toCursor: func(s *Sessions) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Sessions into SessionsEdge.
func (s *Sessions) ToEdge(order *SessionsOrder) *SessionsEdge {
	if order == nil {
		order = DefaultSessionsOrder
	}
	return &SessionsEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// TransactionsEdge is the edge representation of Transactions.
type TransactionsEdge struct {
	Node   *Transactions `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// TransactionsConnection is the connection containing edges to Transactions.
type TransactionsConnection struct {
	Edges      []*TransactionsEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *TransactionsConnection) build(nodes []*Transactions, pager *transactionsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Transactions
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Transactions {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Transactions {
			return nodes[i]
		}
	}
	c.Edges = make([]*TransactionsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TransactionsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TransactionsPaginateOption enables pagination customization.
type TransactionsPaginateOption func(*transactionsPager) error

// WithTransactionsOrder configures pagination ordering.
func WithTransactionsOrder(order *TransactionsOrder) TransactionsPaginateOption {
	if order == nil {
		order = DefaultTransactionsOrder
	}
	o := *order
	return func(pager *transactionsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTransactionsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTransactionsFilter configures pagination filter.
func WithTransactionsFilter(filter func(*TransactionsQuery) (*TransactionsQuery, error)) TransactionsPaginateOption {
	return func(pager *transactionsPager) error {
		if filter == nil {
			return errors.New("TransactionsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type transactionsPager struct {
	order  *TransactionsOrder
	filter func(*TransactionsQuery) (*TransactionsQuery, error)
}

func newTransactionsPager(opts []TransactionsPaginateOption) (*transactionsPager, error) {
	pager := &transactionsPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTransactionsOrder
	}
	return pager, nil
}

func (p *transactionsPager) applyFilter(query *TransactionsQuery) (*TransactionsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *transactionsPager) toCursor(t *Transactions) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *transactionsPager) applyCursors(query *TransactionsQuery, after, before *Cursor) *TransactionsQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTransactionsOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *transactionsPager) applyOrder(query *TransactionsQuery, reverse bool) *TransactionsQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTransactionsOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTransactionsOrder.Field.field))
	}
	return query
}

func (p *transactionsPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTransactionsOrder.Field {
			b.Comma().Ident(DefaultTransactionsOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Transactions.
func (t *TransactionsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TransactionsPaginateOption,
) (*TransactionsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTransactionsPager(opts)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TransactionsConnection{Edges: []*TransactionsEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = t.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	t = pager.applyCursors(t, after, before)
	t = pager.applyOrder(t, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// TransactionsOrderField defines the ordering field of Transactions.
type TransactionsOrderField struct {
	field    string
	toCursor func(*Transactions) Cursor
}

// TransactionsOrder defines the ordering of Transactions.
type TransactionsOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *TransactionsOrderField `json:"field"`
}

// DefaultTransactionsOrder is the default ordering of Transactions.
var DefaultTransactionsOrder = &TransactionsOrder{
	Direction: OrderDirectionAsc,
	Field: &TransactionsOrderField{
		field: transactions.FieldID,
		toCursor: func(t *Transactions) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Transactions into TransactionsEdge.
func (t *Transactions) ToEdge(order *TransactionsOrder) *TransactionsEdge {
	if order == nil {
		order = DefaultTransactionsOrder
	}
	return &TransactionsEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// UsersEdge is the edge representation of Users.
type UsersEdge struct {
	Node   *Users `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UsersConnection is the connection containing edges to Users.
type UsersConnection struct {
	Edges      []*UsersEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *UsersConnection) build(nodes []*Users, pager *usersPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Users
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Users {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Users {
			return nodes[i]
		}
	}
	c.Edges = make([]*UsersEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UsersEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UsersPaginateOption enables pagination customization.
type UsersPaginateOption func(*usersPager) error

// WithUsersOrder configures pagination ordering.
func WithUsersOrder(order *UsersOrder) UsersPaginateOption {
	if order == nil {
		order = DefaultUsersOrder
	}
	o := *order
	return func(pager *usersPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUsersOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUsersFilter configures pagination filter.
func WithUsersFilter(filter func(*UsersQuery) (*UsersQuery, error)) UsersPaginateOption {
	return func(pager *usersPager) error {
		if filter == nil {
			return errors.New("UsersQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type usersPager struct {
	order  *UsersOrder
	filter func(*UsersQuery) (*UsersQuery, error)
}

func newUsersPager(opts []UsersPaginateOption) (*usersPager, error) {
	pager := &usersPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUsersOrder
	}
	return pager, nil
}

func (p *usersPager) applyFilter(query *UsersQuery) (*UsersQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *usersPager) toCursor(u *Users) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *usersPager) applyCursors(query *UsersQuery, after, before *Cursor) *UsersQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUsersOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *usersPager) applyOrder(query *UsersQuery, reverse bool) *UsersQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUsersOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUsersOrder.Field.field))
	}
	return query
}

func (p *usersPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUsersOrder.Field {
			b.Comma().Ident(DefaultUsersOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Users.
func (u *UsersQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UsersPaginateOption,
) (*UsersConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUsersPager(opts)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UsersConnection{Edges: []*UsersEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = u.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	u = pager.applyCursors(u, after, before)
	u = pager.applyOrder(u, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UsersOrderField defines the ordering field of Users.
type UsersOrderField struct {
	field    string
	toCursor func(*Users) Cursor
}

// UsersOrder defines the ordering of Users.
type UsersOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *UsersOrderField `json:"field"`
}

// DefaultUsersOrder is the default ordering of Users.
var DefaultUsersOrder = &UsersOrder{
	Direction: OrderDirectionAsc,
	Field: &UsersOrderField{
		field: users.FieldID,
		toCursor: func(u *Users) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts Users into UsersEdge.
func (u *Users) ToEdge(order *UsersOrder) *UsersEdge {
	if order == nil {
		order = DefaultUsersOrder
	}
	return &UsersEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}
