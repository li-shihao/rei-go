// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"rei.io/rei/ent/account"
	"rei.io/rei/ent/argument"
	"rei.io/rei/ent/event"
	"rei.io/rei/ent/nft"
	"rei.io/rei/ent/object"
	"rei.io/rei/ent/pkg"
	"rei.io/rei/ent/predicate"
	"rei.io/rei/ent/schema"
	"rei.io/rei/ent/session"
	"rei.io/rei/ent/transaction"
	"rei.io/rei/ent/user"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount     = "Account"
	TypeArgument    = "Argument"
	TypeEvent       = "Event"
	TypeNFT         = "NFT"
	TypeObject      = "Object"
	TypePkg         = "Pkg"
	TypeSession     = "Session"
	TypeTransaction = "Transaction"
	TypeUser        = "User"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_SequenceID    *int64
	add_SequenceID *int64
	_AccountID     *string
	_Balance       *int64
	add_Balance    *int64
	_Objects       *[]schema.AccObject
	_Transactions  *[]string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Account, error)
	predicates     []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id int) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSequenceID sets the "SequenceID" field.
func (m *AccountMutation) SetSequenceID(i int64) {
	m._SequenceID = &i
	m.add_SequenceID = nil
}

// SequenceID returns the value of the "SequenceID" field in the mutation.
func (m *AccountMutation) SequenceID() (r int64, exists bool) {
	v := m._SequenceID
	if v == nil {
		return
	}
	return *v, true
}

// OldSequenceID returns the old "SequenceID" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldSequenceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequenceID: %w", err)
	}
	return oldValue.SequenceID, nil
}

// AddSequenceID adds i to the "SequenceID" field.
func (m *AccountMutation) AddSequenceID(i int64) {
	if m.add_SequenceID != nil {
		*m.add_SequenceID += i
	} else {
		m.add_SequenceID = &i
	}
}

// AddedSequenceID returns the value that was added to the "SequenceID" field in this mutation.
func (m *AccountMutation) AddedSequenceID() (r int64, exists bool) {
	v := m.add_SequenceID
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequenceID resets all changes to the "SequenceID" field.
func (m *AccountMutation) ResetSequenceID() {
	m._SequenceID = nil
	m.add_SequenceID = nil
}

// SetAccountID sets the "AccountID" field.
func (m *AccountMutation) SetAccountID(s string) {
	m._AccountID = &s
}

// AccountID returns the value of the "AccountID" field in the mutation.
func (m *AccountMutation) AccountID() (r string, exists bool) {
	v := m._AccountID
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "AccountID" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAccountID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "AccountID" field.
func (m *AccountMutation) ResetAccountID() {
	m._AccountID = nil
}

// SetBalance sets the "Balance" field.
func (m *AccountMutation) SetBalance(i int64) {
	m._Balance = &i
	m.add_Balance = nil
}

// Balance returns the value of the "Balance" field in the mutation.
func (m *AccountMutation) Balance() (r int64, exists bool) {
	v := m._Balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "Balance" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldBalance(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds i to the "Balance" field.
func (m *AccountMutation) AddBalance(i int64) {
	if m.add_Balance != nil {
		*m.add_Balance += i
	} else {
		m.add_Balance = &i
	}
}

// AddedBalance returns the value that was added to the "Balance" field in this mutation.
func (m *AccountMutation) AddedBalance() (r int64, exists bool) {
	v := m.add_Balance
	if v == nil {
		return
	}
	return *v, true
}

// ClearBalance clears the value of the "Balance" field.
func (m *AccountMutation) ClearBalance() {
	m._Balance = nil
	m.add_Balance = nil
	m.clearedFields[account.FieldBalance] = struct{}{}
}

// BalanceCleared returns if the "Balance" field was cleared in this mutation.
func (m *AccountMutation) BalanceCleared() bool {
	_, ok := m.clearedFields[account.FieldBalance]
	return ok
}

// ResetBalance resets all changes to the "Balance" field.
func (m *AccountMutation) ResetBalance() {
	m._Balance = nil
	m.add_Balance = nil
	delete(m.clearedFields, account.FieldBalance)
}

// SetObjects sets the "Objects" field.
func (m *AccountMutation) SetObjects(so []schema.AccObject) {
	m._Objects = &so
}

// Objects returns the value of the "Objects" field in the mutation.
func (m *AccountMutation) Objects() (r []schema.AccObject, exists bool) {
	v := m._Objects
	if v == nil {
		return
	}
	return *v, true
}

// OldObjects returns the old "Objects" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldObjects(ctx context.Context) (v []schema.AccObject, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObjects is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObjects requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObjects: %w", err)
	}
	return oldValue.Objects, nil
}

// ClearObjects clears the value of the "Objects" field.
func (m *AccountMutation) ClearObjects() {
	m._Objects = nil
	m.clearedFields[account.FieldObjects] = struct{}{}
}

// ObjectsCleared returns if the "Objects" field was cleared in this mutation.
func (m *AccountMutation) ObjectsCleared() bool {
	_, ok := m.clearedFields[account.FieldObjects]
	return ok
}

// ResetObjects resets all changes to the "Objects" field.
func (m *AccountMutation) ResetObjects() {
	m._Objects = nil
	delete(m.clearedFields, account.FieldObjects)
}

// SetTransactions sets the "Transactions" field.
func (m *AccountMutation) SetTransactions(s []string) {
	m._Transactions = &s
}

// Transactions returns the value of the "Transactions" field in the mutation.
func (m *AccountMutation) Transactions() (r []string, exists bool) {
	v := m._Transactions
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactions returns the old "Transactions" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldTransactions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactions: %w", err)
	}
	return oldValue.Transactions, nil
}

// ClearTransactions clears the value of the "Transactions" field.
func (m *AccountMutation) ClearTransactions() {
	m._Transactions = nil
	m.clearedFields[account.FieldTransactions] = struct{}{}
}

// TransactionsCleared returns if the "Transactions" field was cleared in this mutation.
func (m *AccountMutation) TransactionsCleared() bool {
	_, ok := m.clearedFields[account.FieldTransactions]
	return ok
}

// ResetTransactions resets all changes to the "Transactions" field.
func (m *AccountMutation) ResetTransactions() {
	m._Transactions = nil
	delete(m.clearedFields, account.FieldTransactions)
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._SequenceID != nil {
		fields = append(fields, account.FieldSequenceID)
	}
	if m._AccountID != nil {
		fields = append(fields, account.FieldAccountID)
	}
	if m._Balance != nil {
		fields = append(fields, account.FieldBalance)
	}
	if m._Objects != nil {
		fields = append(fields, account.FieldObjects)
	}
	if m._Transactions != nil {
		fields = append(fields, account.FieldTransactions)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldSequenceID:
		return m.SequenceID()
	case account.FieldAccountID:
		return m.AccountID()
	case account.FieldBalance:
		return m.Balance()
	case account.FieldObjects:
		return m.Objects()
	case account.FieldTransactions:
		return m.Transactions()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldSequenceID:
		return m.OldSequenceID(ctx)
	case account.FieldAccountID:
		return m.OldAccountID(ctx)
	case account.FieldBalance:
		return m.OldBalance(ctx)
	case account.FieldObjects:
		return m.OldObjects(ctx)
	case account.FieldTransactions:
		return m.OldTransactions(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldSequenceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequenceID(v)
		return nil
	case account.FieldAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case account.FieldBalance:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case account.FieldObjects:
		v, ok := value.([]schema.AccObject)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObjects(v)
		return nil
	case account.FieldTransactions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactions(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.add_SequenceID != nil {
		fields = append(fields, account.FieldSequenceID)
	}
	if m.add_Balance != nil {
		fields = append(fields, account.FieldBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldSequenceID:
		return m.AddedSequenceID()
	case account.FieldBalance:
		return m.AddedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldSequenceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequenceID(v)
		return nil
	case account.FieldBalance:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldBalance) {
		fields = append(fields, account.FieldBalance)
	}
	if m.FieldCleared(account.FieldObjects) {
		fields = append(fields, account.FieldObjects)
	}
	if m.FieldCleared(account.FieldTransactions) {
		fields = append(fields, account.FieldTransactions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldBalance:
		m.ClearBalance()
		return nil
	case account.FieldObjects:
		m.ClearObjects()
		return nil
	case account.FieldTransactions:
		m.ClearTransactions()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldSequenceID:
		m.ResetSequenceID()
		return nil
	case account.FieldAccountID:
		m.ResetAccountID()
		return nil
	case account.FieldBalance:
		m.ResetBalance()
		return nil
	case account.FieldObjects:
		m.ResetObjects()
		return nil
	case account.FieldTransactions:
		m.ResetTransactions()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Account edge %s", name)
}

// ArgumentMutation represents an operation that mutates the Argument nodes in the graph.
type ArgumentMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_Name          *string
	_Type          *string
	_TransactionID *string
	_Data          *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Argument, error)
	predicates     []predicate.Argument
}

var _ ent.Mutation = (*ArgumentMutation)(nil)

// argumentOption allows management of the mutation configuration using functional options.
type argumentOption func(*ArgumentMutation)

// newArgumentMutation creates new mutation for the Argument entity.
func newArgumentMutation(c config, op Op, opts ...argumentOption) *ArgumentMutation {
	m := &ArgumentMutation{
		config:        c,
		op:            op,
		typ:           TypeArgument,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArgumentID sets the ID field of the mutation.
func withArgumentID(id int) argumentOption {
	return func(m *ArgumentMutation) {
		var (
			err   error
			once  sync.Once
			value *Argument
		)
		m.oldValue = func(ctx context.Context) (*Argument, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Argument.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArgument sets the old Argument of the mutation.
func withArgument(node *Argument) argumentOption {
	return func(m *ArgumentMutation) {
		m.oldValue = func(context.Context) (*Argument, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArgumentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArgumentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArgumentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArgumentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Argument.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *ArgumentMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *ArgumentMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Argument entity.
// If the Argument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArgumentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *ArgumentMutation) ResetName() {
	m._Name = nil
}

// SetType sets the "Type" field.
func (m *ArgumentMutation) SetType(s string) {
	m._Type = &s
}

// GetType returns the value of the "Type" field in the mutation.
func (m *ArgumentMutation) GetType() (r string, exists bool) {
	v := m._Type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "Type" field's value of the Argument entity.
// If the Argument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArgumentMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "Type" field.
func (m *ArgumentMutation) ResetType() {
	m._Type = nil
}

// SetTransactionID sets the "TransactionID" field.
func (m *ArgumentMutation) SetTransactionID(s string) {
	m._TransactionID = &s
}

// TransactionID returns the value of the "TransactionID" field in the mutation.
func (m *ArgumentMutation) TransactionID() (r string, exists bool) {
	v := m._TransactionID
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "TransactionID" field's value of the Argument entity.
// If the Argument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArgumentMutation) OldTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ResetTransactionID resets all changes to the "TransactionID" field.
func (m *ArgumentMutation) ResetTransactionID() {
	m._TransactionID = nil
}

// SetData sets the "Data" field.
func (m *ArgumentMutation) SetData(s string) {
	m._Data = &s
}

// Data returns the value of the "Data" field in the mutation.
func (m *ArgumentMutation) Data() (r string, exists bool) {
	v := m._Data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "Data" field's value of the Argument entity.
// If the Argument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArgumentMutation) OldData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "Data" field.
func (m *ArgumentMutation) ResetData() {
	m._Data = nil
}

// Where appends a list predicates to the ArgumentMutation builder.
func (m *ArgumentMutation) Where(ps ...predicate.Argument) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ArgumentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Argument).
func (m *ArgumentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArgumentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._Name != nil {
		fields = append(fields, argument.FieldName)
	}
	if m._Type != nil {
		fields = append(fields, argument.FieldType)
	}
	if m._TransactionID != nil {
		fields = append(fields, argument.FieldTransactionID)
	}
	if m._Data != nil {
		fields = append(fields, argument.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArgumentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case argument.FieldName:
		return m.Name()
	case argument.FieldType:
		return m.GetType()
	case argument.FieldTransactionID:
		return m.TransactionID()
	case argument.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArgumentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case argument.FieldName:
		return m.OldName(ctx)
	case argument.FieldType:
		return m.OldType(ctx)
	case argument.FieldTransactionID:
		return m.OldTransactionID(ctx)
	case argument.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown Argument field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArgumentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case argument.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case argument.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case argument.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	case argument.FieldData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown Argument field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArgumentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArgumentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArgumentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Argument numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArgumentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArgumentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArgumentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Argument nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArgumentMutation) ResetField(name string) error {
	switch name {
	case argument.FieldName:
		m.ResetName()
		return nil
	case argument.FieldType:
		m.ResetType()
		return nil
	case argument.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	case argument.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown Argument field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArgumentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArgumentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArgumentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArgumentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArgumentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArgumentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArgumentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Argument unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArgumentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Argument edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_Type          *string
	_Sender        *string
	_Recipient     *string
	_TransactionID *string
	_ObjectID      *string
	_Version       *uint32
	add_Version    *int32
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Event, error)
	predicates     []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id int) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "Type" field.
func (m *EventMutation) SetType(s string) {
	m._Type = &s
}

// GetType returns the value of the "Type" field in the mutation.
func (m *EventMutation) GetType() (r string, exists bool) {
	v := m._Type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "Type" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "Type" field.
func (m *EventMutation) ResetType() {
	m._Type = nil
}

// SetSender sets the "Sender" field.
func (m *EventMutation) SetSender(s string) {
	m._Sender = &s
}

// Sender returns the value of the "Sender" field in the mutation.
func (m *EventMutation) Sender() (r string, exists bool) {
	v := m._Sender
	if v == nil {
		return
	}
	return *v, true
}

// OldSender returns the old "Sender" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldSender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSender: %w", err)
	}
	return oldValue.Sender, nil
}

// ResetSender resets all changes to the "Sender" field.
func (m *EventMutation) ResetSender() {
	m._Sender = nil
}

// SetRecipient sets the "Recipient" field.
func (m *EventMutation) SetRecipient(s string) {
	m._Recipient = &s
}

// Recipient returns the value of the "Recipient" field in the mutation.
func (m *EventMutation) Recipient() (r string, exists bool) {
	v := m._Recipient
	if v == nil {
		return
	}
	return *v, true
}

// OldRecipient returns the old "Recipient" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldRecipient(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecipient is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecipient requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecipient: %w", err)
	}
	return oldValue.Recipient, nil
}

// ClearRecipient clears the value of the "Recipient" field.
func (m *EventMutation) ClearRecipient() {
	m._Recipient = nil
	m.clearedFields[event.FieldRecipient] = struct{}{}
}

// RecipientCleared returns if the "Recipient" field was cleared in this mutation.
func (m *EventMutation) RecipientCleared() bool {
	_, ok := m.clearedFields[event.FieldRecipient]
	return ok
}

// ResetRecipient resets all changes to the "Recipient" field.
func (m *EventMutation) ResetRecipient() {
	m._Recipient = nil
	delete(m.clearedFields, event.FieldRecipient)
}

// SetTransactionID sets the "TransactionID" field.
func (m *EventMutation) SetTransactionID(s string) {
	m._TransactionID = &s
}

// TransactionID returns the value of the "TransactionID" field in the mutation.
func (m *EventMutation) TransactionID() (r string, exists bool) {
	v := m._TransactionID
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "TransactionID" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ResetTransactionID resets all changes to the "TransactionID" field.
func (m *EventMutation) ResetTransactionID() {
	m._TransactionID = nil
}

// SetObjectID sets the "ObjectID" field.
func (m *EventMutation) SetObjectID(s string) {
	m._ObjectID = &s
}

// ObjectID returns the value of the "ObjectID" field in the mutation.
func (m *EventMutation) ObjectID() (r string, exists bool) {
	v := m._ObjectID
	if v == nil {
		return
	}
	return *v, true
}

// OldObjectID returns the old "ObjectID" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldObjectID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObjectID: %w", err)
	}
	return oldValue.ObjectID, nil
}

// ResetObjectID resets all changes to the "ObjectID" field.
func (m *EventMutation) ResetObjectID() {
	m._ObjectID = nil
}

// SetVersion sets the "Version" field.
func (m *EventMutation) SetVersion(u uint32) {
	m._Version = &u
	m.add_Version = nil
}

// Version returns the value of the "Version" field in the mutation.
func (m *EventMutation) Version() (r uint32, exists bool) {
	v := m._Version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "Version" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldVersion(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds u to the "Version" field.
func (m *EventMutation) AddVersion(u int32) {
	if m.add_Version != nil {
		*m.add_Version += u
	} else {
		m.add_Version = &u
	}
}

// AddedVersion returns the value that was added to the "Version" field in this mutation.
func (m *EventMutation) AddedVersion() (r int32, exists bool) {
	v := m.add_Version
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "Version" field.
func (m *EventMutation) ResetVersion() {
	m._Version = nil
	m.add_Version = nil
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._Type != nil {
		fields = append(fields, event.FieldType)
	}
	if m._Sender != nil {
		fields = append(fields, event.FieldSender)
	}
	if m._Recipient != nil {
		fields = append(fields, event.FieldRecipient)
	}
	if m._TransactionID != nil {
		fields = append(fields, event.FieldTransactionID)
	}
	if m._ObjectID != nil {
		fields = append(fields, event.FieldObjectID)
	}
	if m._Version != nil {
		fields = append(fields, event.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldType:
		return m.GetType()
	case event.FieldSender:
		return m.Sender()
	case event.FieldRecipient:
		return m.Recipient()
	case event.FieldTransactionID:
		return m.TransactionID()
	case event.FieldObjectID:
		return m.ObjectID()
	case event.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldType:
		return m.OldType(ctx)
	case event.FieldSender:
		return m.OldSender(ctx)
	case event.FieldRecipient:
		return m.OldRecipient(ctx)
	case event.FieldTransactionID:
		return m.OldTransactionID(ctx)
	case event.FieldObjectID:
		return m.OldObjectID(ctx)
	case event.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case event.FieldSender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSender(v)
		return nil
	case event.FieldRecipient:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecipient(v)
		return nil
	case event.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	case event.FieldObjectID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObjectID(v)
		return nil
	case event.FieldVersion:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	var fields []string
	if m.add_Version != nil {
		fields = append(fields, event.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case event.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case event.FieldVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(event.FieldRecipient) {
		fields = append(fields, event.FieldRecipient)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	switch name {
	case event.FieldRecipient:
		m.ClearRecipient()
		return nil
	}
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldType:
		m.ResetType()
		return nil
	case event.FieldSender:
		m.ResetSender()
		return nil
	case event.FieldRecipient:
		m.ResetRecipient()
		return nil
	case event.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	case event.FieldObjectID:
		m.ResetObjectID()
		return nil
	case event.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Event edge %s", name)
}

// NFTMutation represents an operation that mutates the NFT nodes in the graph.
type NFTMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_ObjectID      *string
	_Type          *string
	_Metadata      *map[string]interface{}
	_SequenceID    *int64
	add_SequenceID *int64
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*NFT, error)
	predicates     []predicate.NFT
}

var _ ent.Mutation = (*NFTMutation)(nil)

// nftOption allows management of the mutation configuration using functional options.
type nftOption func(*NFTMutation)

// newNFTMutation creates new mutation for the NFT entity.
func newNFTMutation(c config, op Op, opts ...nftOption) *NFTMutation {
	m := &NFTMutation{
		config:        c,
		op:            op,
		typ:           TypeNFT,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNFTID sets the ID field of the mutation.
func withNFTID(id int) nftOption {
	return func(m *NFTMutation) {
		var (
			err   error
			once  sync.Once
			value *NFT
		)
		m.oldValue = func(ctx context.Context) (*NFT, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NFT.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNFT sets the old NFT of the mutation.
func withNFT(node *NFT) nftOption {
	return func(m *NFTMutation) {
		m.oldValue = func(context.Context) (*NFT, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NFTMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NFTMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NFTMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NFTMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NFT.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetObjectID sets the "ObjectID" field.
func (m *NFTMutation) SetObjectID(s string) {
	m._ObjectID = &s
}

// ObjectID returns the value of the "ObjectID" field in the mutation.
func (m *NFTMutation) ObjectID() (r string, exists bool) {
	v := m._ObjectID
	if v == nil {
		return
	}
	return *v, true
}

// OldObjectID returns the old "ObjectID" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldObjectID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObjectID: %w", err)
	}
	return oldValue.ObjectID, nil
}

// ResetObjectID resets all changes to the "ObjectID" field.
func (m *NFTMutation) ResetObjectID() {
	m._ObjectID = nil
}

// SetType sets the "Type" field.
func (m *NFTMutation) SetType(s string) {
	m._Type = &s
}

// GetType returns the value of the "Type" field in the mutation.
func (m *NFTMutation) GetType() (r string, exists bool) {
	v := m._Type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "Type" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "Type" field.
func (m *NFTMutation) ResetType() {
	m._Type = nil
}

// SetMetadata sets the "Metadata" field.
func (m *NFTMutation) SetMetadata(value map[string]interface{}) {
	m._Metadata = &value
}

// Metadata returns the value of the "Metadata" field in the mutation.
func (m *NFTMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m._Metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "Metadata" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "Metadata" field.
func (m *NFTMutation) ResetMetadata() {
	m._Metadata = nil
}

// SetSequenceID sets the "SequenceID" field.
func (m *NFTMutation) SetSequenceID(i int64) {
	m._SequenceID = &i
	m.add_SequenceID = nil
}

// SequenceID returns the value of the "SequenceID" field in the mutation.
func (m *NFTMutation) SequenceID() (r int64, exists bool) {
	v := m._SequenceID
	if v == nil {
		return
	}
	return *v, true
}

// OldSequenceID returns the old "SequenceID" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldSequenceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequenceID: %w", err)
	}
	return oldValue.SequenceID, nil
}

// AddSequenceID adds i to the "SequenceID" field.
func (m *NFTMutation) AddSequenceID(i int64) {
	if m.add_SequenceID != nil {
		*m.add_SequenceID += i
	} else {
		m.add_SequenceID = &i
	}
}

// AddedSequenceID returns the value that was added to the "SequenceID" field in this mutation.
func (m *NFTMutation) AddedSequenceID() (r int64, exists bool) {
	v := m.add_SequenceID
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequenceID resets all changes to the "SequenceID" field.
func (m *NFTMutation) ResetSequenceID() {
	m._SequenceID = nil
	m.add_SequenceID = nil
}

// Where appends a list predicates to the NFTMutation builder.
func (m *NFTMutation) Where(ps ...predicate.NFT) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NFTMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NFT).
func (m *NFTMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NFTMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._ObjectID != nil {
		fields = append(fields, nft.FieldObjectID)
	}
	if m._Type != nil {
		fields = append(fields, nft.FieldType)
	}
	if m._Metadata != nil {
		fields = append(fields, nft.FieldMetadata)
	}
	if m._SequenceID != nil {
		fields = append(fields, nft.FieldSequenceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NFTMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nft.FieldObjectID:
		return m.ObjectID()
	case nft.FieldType:
		return m.GetType()
	case nft.FieldMetadata:
		return m.Metadata()
	case nft.FieldSequenceID:
		return m.SequenceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NFTMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nft.FieldObjectID:
		return m.OldObjectID(ctx)
	case nft.FieldType:
		return m.OldType(ctx)
	case nft.FieldMetadata:
		return m.OldMetadata(ctx)
	case nft.FieldSequenceID:
		return m.OldSequenceID(ctx)
	}
	return nil, fmt.Errorf("unknown NFT field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NFTMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nft.FieldObjectID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObjectID(v)
		return nil
	case nft.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case nft.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case nft.FieldSequenceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequenceID(v)
		return nil
	}
	return fmt.Errorf("unknown NFT field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NFTMutation) AddedFields() []string {
	var fields []string
	if m.add_SequenceID != nil {
		fields = append(fields, nft.FieldSequenceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NFTMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case nft.FieldSequenceID:
		return m.AddedSequenceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NFTMutation) AddField(name string, value ent.Value) error {
	switch name {
	case nft.FieldSequenceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequenceID(v)
		return nil
	}
	return fmt.Errorf("unknown NFT numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NFTMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NFTMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NFTMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NFT nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NFTMutation) ResetField(name string) error {
	switch name {
	case nft.FieldObjectID:
		m.ResetObjectID()
		return nil
	case nft.FieldType:
		m.ResetType()
		return nil
	case nft.FieldMetadata:
		m.ResetMetadata()
		return nil
	case nft.FieldSequenceID:
		m.ResetSequenceID()
		return nil
	}
	return fmt.Errorf("unknown NFT field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NFTMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NFTMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NFTMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NFTMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NFTMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NFTMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NFTMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NFT unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NFTMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NFT edge %s", name)
}

// ObjectMutation represents an operation that mutates the Object nodes in the graph.
type ObjectMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	_Status              *string
	_DataType            *string
	_Type                *string
	_Has_public_transfer *bool
	_Fields              *map[string]interface{}
	_Owner               *string
	_ObjectID            *string
	_TransactionID       *string
	_Version             *int
	add_Version          *int
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*Object, error)
	predicates           []predicate.Object
}

var _ ent.Mutation = (*ObjectMutation)(nil)

// objectOption allows management of the mutation configuration using functional options.
type objectOption func(*ObjectMutation)

// newObjectMutation creates new mutation for the Object entity.
func newObjectMutation(c config, op Op, opts ...objectOption) *ObjectMutation {
	m := &ObjectMutation{
		config:        c,
		op:            op,
		typ:           TypeObject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withObjectID sets the ID field of the mutation.
func withObjectID(id int) objectOption {
	return func(m *ObjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Object
		)
		m.oldValue = func(ctx context.Context) (*Object, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Object.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withObject sets the old Object of the mutation.
func withObject(node *Object) objectOption {
	return func(m *ObjectMutation) {
		m.oldValue = func(context.Context) (*Object, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ObjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ObjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ObjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ObjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Object.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "Status" field.
func (m *ObjectMutation) SetStatus(s string) {
	m._Status = &s
}

// Status returns the value of the "Status" field in the mutation.
func (m *ObjectMutation) Status() (r string, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the Object entity.
// If the Object object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "Status" field.
func (m *ObjectMutation) ResetStatus() {
	m._Status = nil
}

// SetDataType sets the "DataType" field.
func (m *ObjectMutation) SetDataType(s string) {
	m._DataType = &s
}

// DataType returns the value of the "DataType" field in the mutation.
func (m *ObjectMutation) DataType() (r string, exists bool) {
	v := m._DataType
	if v == nil {
		return
	}
	return *v, true
}

// OldDataType returns the old "DataType" field's value of the Object entity.
// If the Object object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectMutation) OldDataType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataType: %w", err)
	}
	return oldValue.DataType, nil
}

// ClearDataType clears the value of the "DataType" field.
func (m *ObjectMutation) ClearDataType() {
	m._DataType = nil
	m.clearedFields[object.FieldDataType] = struct{}{}
}

// DataTypeCleared returns if the "DataType" field was cleared in this mutation.
func (m *ObjectMutation) DataTypeCleared() bool {
	_, ok := m.clearedFields[object.FieldDataType]
	return ok
}

// ResetDataType resets all changes to the "DataType" field.
func (m *ObjectMutation) ResetDataType() {
	m._DataType = nil
	delete(m.clearedFields, object.FieldDataType)
}

// SetType sets the "Type" field.
func (m *ObjectMutation) SetType(s string) {
	m._Type = &s
}

// GetType returns the value of the "Type" field in the mutation.
func (m *ObjectMutation) GetType() (r string, exists bool) {
	v := m._Type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "Type" field's value of the Object entity.
// If the Object object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "Type" field.
func (m *ObjectMutation) ClearType() {
	m._Type = nil
	m.clearedFields[object.FieldType] = struct{}{}
}

// TypeCleared returns if the "Type" field was cleared in this mutation.
func (m *ObjectMutation) TypeCleared() bool {
	_, ok := m.clearedFields[object.FieldType]
	return ok
}

// ResetType resets all changes to the "Type" field.
func (m *ObjectMutation) ResetType() {
	m._Type = nil
	delete(m.clearedFields, object.FieldType)
}

// SetHasPublicTransfer sets the "Has_public_transfer" field.
func (m *ObjectMutation) SetHasPublicTransfer(b bool) {
	m._Has_public_transfer = &b
}

// HasPublicTransfer returns the value of the "Has_public_transfer" field in the mutation.
func (m *ObjectMutation) HasPublicTransfer() (r bool, exists bool) {
	v := m._Has_public_transfer
	if v == nil {
		return
	}
	return *v, true
}

// OldHasPublicTransfer returns the old "Has_public_transfer" field's value of the Object entity.
// If the Object object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectMutation) OldHasPublicTransfer(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasPublicTransfer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasPublicTransfer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasPublicTransfer: %w", err)
	}
	return oldValue.HasPublicTransfer, nil
}

// ClearHasPublicTransfer clears the value of the "Has_public_transfer" field.
func (m *ObjectMutation) ClearHasPublicTransfer() {
	m._Has_public_transfer = nil
	m.clearedFields[object.FieldHasPublicTransfer] = struct{}{}
}

// HasPublicTransferCleared returns if the "Has_public_transfer" field was cleared in this mutation.
func (m *ObjectMutation) HasPublicTransferCleared() bool {
	_, ok := m.clearedFields[object.FieldHasPublicTransfer]
	return ok
}

// ResetHasPublicTransfer resets all changes to the "Has_public_transfer" field.
func (m *ObjectMutation) ResetHasPublicTransfer() {
	m._Has_public_transfer = nil
	delete(m.clearedFields, object.FieldHasPublicTransfer)
}

// SetFields sets the "Fields" field.
func (m *ObjectMutation) SetFields(value map[string]interface{}) {
	m._Fields = &value
}

// GetFields returns the value of the "Fields" field in the mutation.
func (m *ObjectMutation) GetFields() (r map[string]interface{}, exists bool) {
	v := m._Fields
	if v == nil {
		return
	}
	return *v, true
}

// OldFields returns the old "Fields" field's value of the Object entity.
// If the Object object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectMutation) OldFields(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFields: %w", err)
	}
	return oldValue.Fields, nil
}

// ClearFields clears the value of the "Fields" field.
func (m *ObjectMutation) ClearFields() {
	m._Fields = nil
	m.clearedFields[object.FieldFields] = struct{}{}
}

// FieldsCleared returns if the "Fields" field was cleared in this mutation.
func (m *ObjectMutation) FieldsCleared() bool {
	_, ok := m.clearedFields[object.FieldFields]
	return ok
}

// ResetFields resets all changes to the "Fields" field.
func (m *ObjectMutation) ResetFields() {
	m._Fields = nil
	delete(m.clearedFields, object.FieldFields)
}

// SetOwner sets the "Owner" field.
func (m *ObjectMutation) SetOwner(s string) {
	m._Owner = &s
}

// Owner returns the value of the "Owner" field in the mutation.
func (m *ObjectMutation) Owner() (r string, exists bool) {
	v := m._Owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "Owner" field's value of the Object entity.
// If the Object object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ClearOwner clears the value of the "Owner" field.
func (m *ObjectMutation) ClearOwner() {
	m._Owner = nil
	m.clearedFields[object.FieldOwner] = struct{}{}
}

// OwnerCleared returns if the "Owner" field was cleared in this mutation.
func (m *ObjectMutation) OwnerCleared() bool {
	_, ok := m.clearedFields[object.FieldOwner]
	return ok
}

// ResetOwner resets all changes to the "Owner" field.
func (m *ObjectMutation) ResetOwner() {
	m._Owner = nil
	delete(m.clearedFields, object.FieldOwner)
}

// SetObjectID sets the "ObjectID" field.
func (m *ObjectMutation) SetObjectID(s string) {
	m._ObjectID = &s
}

// ObjectID returns the value of the "ObjectID" field in the mutation.
func (m *ObjectMutation) ObjectID() (r string, exists bool) {
	v := m._ObjectID
	if v == nil {
		return
	}
	return *v, true
}

// OldObjectID returns the old "ObjectID" field's value of the Object entity.
// If the Object object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectMutation) OldObjectID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObjectID: %w", err)
	}
	return oldValue.ObjectID, nil
}

// ResetObjectID resets all changes to the "ObjectID" field.
func (m *ObjectMutation) ResetObjectID() {
	m._ObjectID = nil
}

// SetTransactionID sets the "TransactionID" field.
func (m *ObjectMutation) SetTransactionID(s string) {
	m._TransactionID = &s
}

// TransactionID returns the value of the "TransactionID" field in the mutation.
func (m *ObjectMutation) TransactionID() (r string, exists bool) {
	v := m._TransactionID
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "TransactionID" field's value of the Object entity.
// If the Object object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectMutation) OldTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ResetTransactionID resets all changes to the "TransactionID" field.
func (m *ObjectMutation) ResetTransactionID() {
	m._TransactionID = nil
}

// SetVersion sets the "Version" field.
func (m *ObjectMutation) SetVersion(i int) {
	m._Version = &i
	m.add_Version = nil
}

// Version returns the value of the "Version" field in the mutation.
func (m *ObjectMutation) Version() (r int, exists bool) {
	v := m._Version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "Version" field's value of the Object entity.
// If the Object object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "Version" field.
func (m *ObjectMutation) AddVersion(i int) {
	if m.add_Version != nil {
		*m.add_Version += i
	} else {
		m.add_Version = &i
	}
}

// AddedVersion returns the value that was added to the "Version" field in this mutation.
func (m *ObjectMutation) AddedVersion() (r int, exists bool) {
	v := m.add_Version
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "Version" field.
func (m *ObjectMutation) ResetVersion() {
	m._Version = nil
	m.add_Version = nil
}

// Where appends a list predicates to the ObjectMutation builder.
func (m *ObjectMutation) Where(ps ...predicate.Object) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ObjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Object).
func (m *ObjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ObjectMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m._Status != nil {
		fields = append(fields, object.FieldStatus)
	}
	if m._DataType != nil {
		fields = append(fields, object.FieldDataType)
	}
	if m._Type != nil {
		fields = append(fields, object.FieldType)
	}
	if m._Has_public_transfer != nil {
		fields = append(fields, object.FieldHasPublicTransfer)
	}
	if m._Fields != nil {
		fields = append(fields, object.FieldFields)
	}
	if m._Owner != nil {
		fields = append(fields, object.FieldOwner)
	}
	if m._ObjectID != nil {
		fields = append(fields, object.FieldObjectID)
	}
	if m._TransactionID != nil {
		fields = append(fields, object.FieldTransactionID)
	}
	if m._Version != nil {
		fields = append(fields, object.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ObjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case object.FieldStatus:
		return m.Status()
	case object.FieldDataType:
		return m.DataType()
	case object.FieldType:
		return m.GetType()
	case object.FieldHasPublicTransfer:
		return m.HasPublicTransfer()
	case object.FieldFields:
		return m.GetFields()
	case object.FieldOwner:
		return m.Owner()
	case object.FieldObjectID:
		return m.ObjectID()
	case object.FieldTransactionID:
		return m.TransactionID()
	case object.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ObjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case object.FieldStatus:
		return m.OldStatus(ctx)
	case object.FieldDataType:
		return m.OldDataType(ctx)
	case object.FieldType:
		return m.OldType(ctx)
	case object.FieldHasPublicTransfer:
		return m.OldHasPublicTransfer(ctx)
	case object.FieldFields:
		return m.OldFields(ctx)
	case object.FieldOwner:
		return m.OldOwner(ctx)
	case object.FieldObjectID:
		return m.OldObjectID(ctx)
	case object.FieldTransactionID:
		return m.OldTransactionID(ctx)
	case object.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown Object field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ObjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case object.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case object.FieldDataType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataType(v)
		return nil
	case object.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case object.FieldHasPublicTransfer:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasPublicTransfer(v)
		return nil
	case object.FieldFields:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFields(v)
		return nil
	case object.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case object.FieldObjectID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObjectID(v)
		return nil
	case object.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	case object.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Object field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ObjectMutation) AddedFields() []string {
	var fields []string
	if m.add_Version != nil {
		fields = append(fields, object.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ObjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case object.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ObjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case object.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Object numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ObjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(object.FieldDataType) {
		fields = append(fields, object.FieldDataType)
	}
	if m.FieldCleared(object.FieldType) {
		fields = append(fields, object.FieldType)
	}
	if m.FieldCleared(object.FieldHasPublicTransfer) {
		fields = append(fields, object.FieldHasPublicTransfer)
	}
	if m.FieldCleared(object.FieldFields) {
		fields = append(fields, object.FieldFields)
	}
	if m.FieldCleared(object.FieldOwner) {
		fields = append(fields, object.FieldOwner)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ObjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ObjectMutation) ClearField(name string) error {
	switch name {
	case object.FieldDataType:
		m.ClearDataType()
		return nil
	case object.FieldType:
		m.ClearType()
		return nil
	case object.FieldHasPublicTransfer:
		m.ClearHasPublicTransfer()
		return nil
	case object.FieldFields:
		m.ClearFields()
		return nil
	case object.FieldOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Object nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ObjectMutation) ResetField(name string) error {
	switch name {
	case object.FieldStatus:
		m.ResetStatus()
		return nil
	case object.FieldDataType:
		m.ResetDataType()
		return nil
	case object.FieldType:
		m.ResetType()
		return nil
	case object.FieldHasPublicTransfer:
		m.ResetHasPublicTransfer()
		return nil
	case object.FieldFields:
		m.ResetFields()
		return nil
	case object.FieldOwner:
		m.ResetOwner()
		return nil
	case object.FieldObjectID:
		m.ResetObjectID()
		return nil
	case object.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	case object.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown Object field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ObjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ObjectMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ObjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ObjectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ObjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ObjectMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ObjectMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Object unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ObjectMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Object edge %s", name)
}

// PkgMutation represents an operation that mutates the Pkg nodes in the graph.
type PkgMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_TransactionID *string
	_ObjectID      *string
	_Bytecode      *map[string]interface{}
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Pkg, error)
	predicates     []predicate.Pkg
}

var _ ent.Mutation = (*PkgMutation)(nil)

// pkgOption allows management of the mutation configuration using functional options.
type pkgOption func(*PkgMutation)

// newPkgMutation creates new mutation for the Pkg entity.
func newPkgMutation(c config, op Op, opts ...pkgOption) *PkgMutation {
	m := &PkgMutation{
		config:        c,
		op:            op,
		typ:           TypePkg,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPkgID sets the ID field of the mutation.
func withPkgID(id int) pkgOption {
	return func(m *PkgMutation) {
		var (
			err   error
			once  sync.Once
			value *Pkg
		)
		m.oldValue = func(ctx context.Context) (*Pkg, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pkg.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPkg sets the old Pkg of the mutation.
func withPkg(node *Pkg) pkgOption {
	return func(m *PkgMutation) {
		m.oldValue = func(context.Context) (*Pkg, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PkgMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PkgMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PkgMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PkgMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Pkg.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTransactionID sets the "TransactionID" field.
func (m *PkgMutation) SetTransactionID(s string) {
	m._TransactionID = &s
}

// TransactionID returns the value of the "TransactionID" field in the mutation.
func (m *PkgMutation) TransactionID() (r string, exists bool) {
	v := m._TransactionID
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "TransactionID" field's value of the Pkg entity.
// If the Pkg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkgMutation) OldTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ResetTransactionID resets all changes to the "TransactionID" field.
func (m *PkgMutation) ResetTransactionID() {
	m._TransactionID = nil
}

// SetObjectID sets the "ObjectID" field.
func (m *PkgMutation) SetObjectID(s string) {
	m._ObjectID = &s
}

// ObjectID returns the value of the "ObjectID" field in the mutation.
func (m *PkgMutation) ObjectID() (r string, exists bool) {
	v := m._ObjectID
	if v == nil {
		return
	}
	return *v, true
}

// OldObjectID returns the old "ObjectID" field's value of the Pkg entity.
// If the Pkg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkgMutation) OldObjectID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObjectID: %w", err)
	}
	return oldValue.ObjectID, nil
}

// ResetObjectID resets all changes to the "ObjectID" field.
func (m *PkgMutation) ResetObjectID() {
	m._ObjectID = nil
}

// SetBytecode sets the "Bytecode" field.
func (m *PkgMutation) SetBytecode(value map[string]interface{}) {
	m._Bytecode = &value
}

// Bytecode returns the value of the "Bytecode" field in the mutation.
func (m *PkgMutation) Bytecode() (r map[string]interface{}, exists bool) {
	v := m._Bytecode
	if v == nil {
		return
	}
	return *v, true
}

// OldBytecode returns the old "Bytecode" field's value of the Pkg entity.
// If the Pkg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkgMutation) OldBytecode(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBytecode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBytecode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBytecode: %w", err)
	}
	return oldValue.Bytecode, nil
}

// ResetBytecode resets all changes to the "Bytecode" field.
func (m *PkgMutation) ResetBytecode() {
	m._Bytecode = nil
}

// Where appends a list predicates to the PkgMutation builder.
func (m *PkgMutation) Where(ps ...predicate.Pkg) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PkgMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Pkg).
func (m *PkgMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PkgMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._TransactionID != nil {
		fields = append(fields, pkg.FieldTransactionID)
	}
	if m._ObjectID != nil {
		fields = append(fields, pkg.FieldObjectID)
	}
	if m._Bytecode != nil {
		fields = append(fields, pkg.FieldBytecode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PkgMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pkg.FieldTransactionID:
		return m.TransactionID()
	case pkg.FieldObjectID:
		return m.ObjectID()
	case pkg.FieldBytecode:
		return m.Bytecode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PkgMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pkg.FieldTransactionID:
		return m.OldTransactionID(ctx)
	case pkg.FieldObjectID:
		return m.OldObjectID(ctx)
	case pkg.FieldBytecode:
		return m.OldBytecode(ctx)
	}
	return nil, fmt.Errorf("unknown Pkg field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PkgMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pkg.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	case pkg.FieldObjectID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObjectID(v)
		return nil
	case pkg.FieldBytecode:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBytecode(v)
		return nil
	}
	return fmt.Errorf("unknown Pkg field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PkgMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PkgMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PkgMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Pkg numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PkgMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PkgMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PkgMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Pkg nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PkgMutation) ResetField(name string) error {
	switch name {
	case pkg.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	case pkg.FieldObjectID:
		m.ResetObjectID()
		return nil
	case pkg.FieldBytecode:
		m.ResetBytecode()
		return nil
	}
	return fmt.Errorf("unknown Pkg field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PkgMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PkgMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PkgMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PkgMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PkgMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PkgMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PkgMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Pkg unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PkgMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Pkg edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Username     *string
	_LoginTime    *time.Time
	_LoginIP      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Session, error)
	predicates    []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id int) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "Username" field.
func (m *SessionMutation) SetUsername(s string) {
	m._Username = &s
}

// Username returns the value of the "Username" field in the mutation.
func (m *SessionMutation) Username() (r string, exists bool) {
	v := m._Username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "Username" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "Username" field.
func (m *SessionMutation) ResetUsername() {
	m._Username = nil
}

// SetLoginTime sets the "LoginTime" field.
func (m *SessionMutation) SetLoginTime(t time.Time) {
	m._LoginTime = &t
}

// LoginTime returns the value of the "LoginTime" field in the mutation.
func (m *SessionMutation) LoginTime() (r time.Time, exists bool) {
	v := m._LoginTime
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginTime returns the old "LoginTime" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldLoginTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginTime: %w", err)
	}
	return oldValue.LoginTime, nil
}

// ResetLoginTime resets all changes to the "LoginTime" field.
func (m *SessionMutation) ResetLoginTime() {
	m._LoginTime = nil
}

// SetLoginIP sets the "LoginIP" field.
func (m *SessionMutation) SetLoginIP(s string) {
	m._LoginIP = &s
}

// LoginIP returns the value of the "LoginIP" field in the mutation.
func (m *SessionMutation) LoginIP() (r string, exists bool) {
	v := m._LoginIP
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginIP returns the old "LoginIP" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldLoginIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginIP: %w", err)
	}
	return oldValue.LoginIP, nil
}

// ResetLoginIP resets all changes to the "LoginIP" field.
func (m *SessionMutation) ResetLoginIP() {
	m._LoginIP = nil
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._Username != nil {
		fields = append(fields, session.FieldUsername)
	}
	if m._LoginTime != nil {
		fields = append(fields, session.FieldLoginTime)
	}
	if m._LoginIP != nil {
		fields = append(fields, session.FieldLoginIP)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldUsername:
		return m.Username()
	case session.FieldLoginTime:
		return m.LoginTime()
	case session.FieldLoginIP:
		return m.LoginIP()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldUsername:
		return m.OldUsername(ctx)
	case session.FieldLoginTime:
		return m.OldLoginTime(ctx)
	case session.FieldLoginIP:
		return m.OldLoginIP(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case session.FieldLoginTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginTime(v)
		return nil
	case session.FieldLoginIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginIP(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldUsername:
		m.ResetUsername()
		return nil
	case session.FieldLoginTime:
		m.ResetLoginTime()
		return nil
	case session.FieldLoginIP:
		m.ResetLoginIP()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Session edge %s", name)
}

// TransactionMutation represents an operation that mutates the Transaction nodes in the graph.
type TransactionMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_Type          *string
	_Time          *time.Time
	_TransactionID *string
	_Status        *bool
	_Sender        *string
	_Recipient     *string
	_Amount        *float64
	add_Amount     *float64
	_Package       *string
	_Module        *string
	_Function      *string
	_Gas           *uint32
	add_Gas        *int32
	_Changed       *[]schema.Changed
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Transaction, error)
	predicates     []predicate.Transaction
}

var _ ent.Mutation = (*TransactionMutation)(nil)

// transactionOption allows management of the mutation configuration using functional options.
type transactionOption func(*TransactionMutation)

// newTransactionMutation creates new mutation for the Transaction entity.
func newTransactionMutation(c config, op Op, opts ...transactionOption) *TransactionMutation {
	m := &TransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionID sets the ID field of the mutation.
func withTransactionID(id int) transactionOption {
	return func(m *TransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Transaction
		)
		m.oldValue = func(ctx context.Context) (*Transaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransaction sets the old Transaction of the mutation.
func withTransaction(node *Transaction) transactionOption {
	return func(m *TransactionMutation) {
		m.oldValue = func(context.Context) (*Transaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "Type" field.
func (m *TransactionMutation) SetType(s string) {
	m._Type = &s
}

// GetType returns the value of the "Type" field in the mutation.
func (m *TransactionMutation) GetType() (r string, exists bool) {
	v := m._Type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "Type" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "Type" field.
func (m *TransactionMutation) ResetType() {
	m._Type = nil
}

// SetTime sets the "Time" field.
func (m *TransactionMutation) SetTime(t time.Time) {
	m._Time = &t
}

// Time returns the value of the "Time" field in the mutation.
func (m *TransactionMutation) Time() (r time.Time, exists bool) {
	v := m._Time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "Time" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "Time" field.
func (m *TransactionMutation) ResetTime() {
	m._Time = nil
}

// SetTransactionID sets the "TransactionID" field.
func (m *TransactionMutation) SetTransactionID(s string) {
	m._TransactionID = &s
}

// TransactionID returns the value of the "TransactionID" field in the mutation.
func (m *TransactionMutation) TransactionID() (r string, exists bool) {
	v := m._TransactionID
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "TransactionID" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ResetTransactionID resets all changes to the "TransactionID" field.
func (m *TransactionMutation) ResetTransactionID() {
	m._TransactionID = nil
}

// SetStatus sets the "Status" field.
func (m *TransactionMutation) SetStatus(b bool) {
	m._Status = &b
}

// Status returns the value of the "Status" field in the mutation.
func (m *TransactionMutation) Status() (r bool, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "Status" field.
func (m *TransactionMutation) ResetStatus() {
	m._Status = nil
}

// SetSender sets the "Sender" field.
func (m *TransactionMutation) SetSender(s string) {
	m._Sender = &s
}

// Sender returns the value of the "Sender" field in the mutation.
func (m *TransactionMutation) Sender() (r string, exists bool) {
	v := m._Sender
	if v == nil {
		return
	}
	return *v, true
}

// OldSender returns the old "Sender" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldSender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSender: %w", err)
	}
	return oldValue.Sender, nil
}

// ResetSender resets all changes to the "Sender" field.
func (m *TransactionMutation) ResetSender() {
	m._Sender = nil
}

// SetRecipient sets the "Recipient" field.
func (m *TransactionMutation) SetRecipient(s string) {
	m._Recipient = &s
}

// Recipient returns the value of the "Recipient" field in the mutation.
func (m *TransactionMutation) Recipient() (r string, exists bool) {
	v := m._Recipient
	if v == nil {
		return
	}
	return *v, true
}

// OldRecipient returns the old "Recipient" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldRecipient(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecipient is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecipient requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecipient: %w", err)
	}
	return oldValue.Recipient, nil
}

// ClearRecipient clears the value of the "Recipient" field.
func (m *TransactionMutation) ClearRecipient() {
	m._Recipient = nil
	m.clearedFields[transaction.FieldRecipient] = struct{}{}
}

// RecipientCleared returns if the "Recipient" field was cleared in this mutation.
func (m *TransactionMutation) RecipientCleared() bool {
	_, ok := m.clearedFields[transaction.FieldRecipient]
	return ok
}

// ResetRecipient resets all changes to the "Recipient" field.
func (m *TransactionMutation) ResetRecipient() {
	m._Recipient = nil
	delete(m.clearedFields, transaction.FieldRecipient)
}

// SetAmount sets the "Amount" field.
func (m *TransactionMutation) SetAmount(f float64) {
	m._Amount = &f
	m.add_Amount = nil
}

// Amount returns the value of the "Amount" field in the mutation.
func (m *TransactionMutation) Amount() (r float64, exists bool) {
	v := m._Amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "Amount" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "Amount" field.
func (m *TransactionMutation) AddAmount(f float64) {
	if m.add_Amount != nil {
		*m.add_Amount += f
	} else {
		m.add_Amount = &f
	}
}

// AddedAmount returns the value that was added to the "Amount" field in this mutation.
func (m *TransactionMutation) AddedAmount() (r float64, exists bool) {
	v := m.add_Amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "Amount" field.
func (m *TransactionMutation) ClearAmount() {
	m._Amount = nil
	m.add_Amount = nil
	m.clearedFields[transaction.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "Amount" field was cleared in this mutation.
func (m *TransactionMutation) AmountCleared() bool {
	_, ok := m.clearedFields[transaction.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "Amount" field.
func (m *TransactionMutation) ResetAmount() {
	m._Amount = nil
	m.add_Amount = nil
	delete(m.clearedFields, transaction.FieldAmount)
}

// SetPackage sets the "Package" field.
func (m *TransactionMutation) SetPackage(s string) {
	m._Package = &s
}

// Package returns the value of the "Package" field in the mutation.
func (m *TransactionMutation) Package() (r string, exists bool) {
	v := m._Package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackage returns the old "Package" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldPackage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackage: %w", err)
	}
	return oldValue.Package, nil
}

// ClearPackage clears the value of the "Package" field.
func (m *TransactionMutation) ClearPackage() {
	m._Package = nil
	m.clearedFields[transaction.FieldPackage] = struct{}{}
}

// PackageCleared returns if the "Package" field was cleared in this mutation.
func (m *TransactionMutation) PackageCleared() bool {
	_, ok := m.clearedFields[transaction.FieldPackage]
	return ok
}

// ResetPackage resets all changes to the "Package" field.
func (m *TransactionMutation) ResetPackage() {
	m._Package = nil
	delete(m.clearedFields, transaction.FieldPackage)
}

// SetModule sets the "Module" field.
func (m *TransactionMutation) SetModule(s string) {
	m._Module = &s
}

// Module returns the value of the "Module" field in the mutation.
func (m *TransactionMutation) Module() (r string, exists bool) {
	v := m._Module
	if v == nil {
		return
	}
	return *v, true
}

// OldModule returns the old "Module" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldModule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModule: %w", err)
	}
	return oldValue.Module, nil
}

// ClearModule clears the value of the "Module" field.
func (m *TransactionMutation) ClearModule() {
	m._Module = nil
	m.clearedFields[transaction.FieldModule] = struct{}{}
}

// ModuleCleared returns if the "Module" field was cleared in this mutation.
func (m *TransactionMutation) ModuleCleared() bool {
	_, ok := m.clearedFields[transaction.FieldModule]
	return ok
}

// ResetModule resets all changes to the "Module" field.
func (m *TransactionMutation) ResetModule() {
	m._Module = nil
	delete(m.clearedFields, transaction.FieldModule)
}

// SetFunction sets the "Function" field.
func (m *TransactionMutation) SetFunction(s string) {
	m._Function = &s
}

// Function returns the value of the "Function" field in the mutation.
func (m *TransactionMutation) Function() (r string, exists bool) {
	v := m._Function
	if v == nil {
		return
	}
	return *v, true
}

// OldFunction returns the old "Function" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldFunction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFunction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFunction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFunction: %w", err)
	}
	return oldValue.Function, nil
}

// ClearFunction clears the value of the "Function" field.
func (m *TransactionMutation) ClearFunction() {
	m._Function = nil
	m.clearedFields[transaction.FieldFunction] = struct{}{}
}

// FunctionCleared returns if the "Function" field was cleared in this mutation.
func (m *TransactionMutation) FunctionCleared() bool {
	_, ok := m.clearedFields[transaction.FieldFunction]
	return ok
}

// ResetFunction resets all changes to the "Function" field.
func (m *TransactionMutation) ResetFunction() {
	m._Function = nil
	delete(m.clearedFields, transaction.FieldFunction)
}

// SetGas sets the "Gas" field.
func (m *TransactionMutation) SetGas(u uint32) {
	m._Gas = &u
	m.add_Gas = nil
}

// Gas returns the value of the "Gas" field in the mutation.
func (m *TransactionMutation) Gas() (r uint32, exists bool) {
	v := m._Gas
	if v == nil {
		return
	}
	return *v, true
}

// OldGas returns the old "Gas" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldGas(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGas is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGas requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGas: %w", err)
	}
	return oldValue.Gas, nil
}

// AddGas adds u to the "Gas" field.
func (m *TransactionMutation) AddGas(u int32) {
	if m.add_Gas != nil {
		*m.add_Gas += u
	} else {
		m.add_Gas = &u
	}
}

// AddedGas returns the value that was added to the "Gas" field in this mutation.
func (m *TransactionMutation) AddedGas() (r int32, exists bool) {
	v := m.add_Gas
	if v == nil {
		return
	}
	return *v, true
}

// ResetGas resets all changes to the "Gas" field.
func (m *TransactionMutation) ResetGas() {
	m._Gas = nil
	m.add_Gas = nil
}

// SetChanged sets the "Changed" field.
func (m *TransactionMutation) SetChanged(s []schema.Changed) {
	m._Changed = &s
}

// Changed returns the value of the "Changed" field in the mutation.
func (m *TransactionMutation) Changed() (r []schema.Changed, exists bool) {
	v := m._Changed
	if v == nil {
		return
	}
	return *v, true
}

// OldChanged returns the old "Changed" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldChanged(ctx context.Context) (v []schema.Changed, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChanged is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChanged requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChanged: %w", err)
	}
	return oldValue.Changed, nil
}

// ClearChanged clears the value of the "Changed" field.
func (m *TransactionMutation) ClearChanged() {
	m._Changed = nil
	m.clearedFields[transaction.FieldChanged] = struct{}{}
}

// ChangedCleared returns if the "Changed" field was cleared in this mutation.
func (m *TransactionMutation) ChangedCleared() bool {
	_, ok := m.clearedFields[transaction.FieldChanged]
	return ok
}

// ResetChanged resets all changes to the "Changed" field.
func (m *TransactionMutation) ResetChanged() {
	m._Changed = nil
	delete(m.clearedFields, transaction.FieldChanged)
}

// Where appends a list predicates to the TransactionMutation builder.
func (m *TransactionMutation) Where(ps ...predicate.Transaction) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TransactionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Transaction).
func (m *TransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m._Type != nil {
		fields = append(fields, transaction.FieldType)
	}
	if m._Time != nil {
		fields = append(fields, transaction.FieldTime)
	}
	if m._TransactionID != nil {
		fields = append(fields, transaction.FieldTransactionID)
	}
	if m._Status != nil {
		fields = append(fields, transaction.FieldStatus)
	}
	if m._Sender != nil {
		fields = append(fields, transaction.FieldSender)
	}
	if m._Recipient != nil {
		fields = append(fields, transaction.FieldRecipient)
	}
	if m._Amount != nil {
		fields = append(fields, transaction.FieldAmount)
	}
	if m._Package != nil {
		fields = append(fields, transaction.FieldPackage)
	}
	if m._Module != nil {
		fields = append(fields, transaction.FieldModule)
	}
	if m._Function != nil {
		fields = append(fields, transaction.FieldFunction)
	}
	if m._Gas != nil {
		fields = append(fields, transaction.FieldGas)
	}
	if m._Changed != nil {
		fields = append(fields, transaction.FieldChanged)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldType:
		return m.GetType()
	case transaction.FieldTime:
		return m.Time()
	case transaction.FieldTransactionID:
		return m.TransactionID()
	case transaction.FieldStatus:
		return m.Status()
	case transaction.FieldSender:
		return m.Sender()
	case transaction.FieldRecipient:
		return m.Recipient()
	case transaction.FieldAmount:
		return m.Amount()
	case transaction.FieldPackage:
		return m.Package()
	case transaction.FieldModule:
		return m.Module()
	case transaction.FieldFunction:
		return m.Function()
	case transaction.FieldGas:
		return m.Gas()
	case transaction.FieldChanged:
		return m.Changed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transaction.FieldType:
		return m.OldType(ctx)
	case transaction.FieldTime:
		return m.OldTime(ctx)
	case transaction.FieldTransactionID:
		return m.OldTransactionID(ctx)
	case transaction.FieldStatus:
		return m.OldStatus(ctx)
	case transaction.FieldSender:
		return m.OldSender(ctx)
	case transaction.FieldRecipient:
		return m.OldRecipient(ctx)
	case transaction.FieldAmount:
		return m.OldAmount(ctx)
	case transaction.FieldPackage:
		return m.OldPackage(ctx)
	case transaction.FieldModule:
		return m.OldModule(ctx)
	case transaction.FieldFunction:
		return m.OldFunction(ctx)
	case transaction.FieldGas:
		return m.OldGas(ctx)
	case transaction.FieldChanged:
		return m.OldChanged(ctx)
	}
	return nil, fmt.Errorf("unknown Transaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case transaction.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case transaction.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	case transaction.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case transaction.FieldSender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSender(v)
		return nil
	case transaction.FieldRecipient:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecipient(v)
		return nil
	case transaction.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case transaction.FieldPackage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackage(v)
		return nil
	case transaction.FieldModule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModule(v)
		return nil
	case transaction.FieldFunction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFunction(v)
		return nil
	case transaction.FieldGas:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGas(v)
		return nil
	case transaction.FieldChanged:
		v, ok := value.([]schema.Changed)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChanged(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionMutation) AddedFields() []string {
	var fields []string
	if m.add_Amount != nil {
		fields = append(fields, transaction.FieldAmount)
	}
	if m.add_Gas != nil {
		fields = append(fields, transaction.FieldGas)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldAmount:
		return m.AddedAmount()
	case transaction.FieldGas:
		return m.AddedGas()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case transaction.FieldGas:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGas(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transaction.FieldRecipient) {
		fields = append(fields, transaction.FieldRecipient)
	}
	if m.FieldCleared(transaction.FieldAmount) {
		fields = append(fields, transaction.FieldAmount)
	}
	if m.FieldCleared(transaction.FieldPackage) {
		fields = append(fields, transaction.FieldPackage)
	}
	if m.FieldCleared(transaction.FieldModule) {
		fields = append(fields, transaction.FieldModule)
	}
	if m.FieldCleared(transaction.FieldFunction) {
		fields = append(fields, transaction.FieldFunction)
	}
	if m.FieldCleared(transaction.FieldChanged) {
		fields = append(fields, transaction.FieldChanged)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionMutation) ClearField(name string) error {
	switch name {
	case transaction.FieldRecipient:
		m.ClearRecipient()
		return nil
	case transaction.FieldAmount:
		m.ClearAmount()
		return nil
	case transaction.FieldPackage:
		m.ClearPackage()
		return nil
	case transaction.FieldModule:
		m.ClearModule()
		return nil
	case transaction.FieldFunction:
		m.ClearFunction()
		return nil
	case transaction.FieldChanged:
		m.ClearChanged()
		return nil
	}
	return fmt.Errorf("unknown Transaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionMutation) ResetField(name string) error {
	switch name {
	case transaction.FieldType:
		m.ResetType()
		return nil
	case transaction.FieldTime:
		m.ResetTime()
		return nil
	case transaction.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	case transaction.FieldStatus:
		m.ResetStatus()
		return nil
	case transaction.FieldSender:
		m.ResetSender()
		return nil
	case transaction.FieldRecipient:
		m.ResetRecipient()
		return nil
	case transaction.FieldAmount:
		m.ResetAmount()
		return nil
	case transaction.FieldPackage:
		m.ResetPackage()
		return nil
	case transaction.FieldModule:
		m.ResetModule()
		return nil
	case transaction.FieldFunction:
		m.ResetFunction()
		return nil
	case transaction.FieldGas:
		m.ResetGas()
		return nil
	case transaction.FieldChanged:
		m.ResetChanged()
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Transaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Transaction edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Username     *string
	_Hash         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "Username" field.
func (m *UserMutation) SetUsername(s string) {
	m._Username = &s
}

// Username returns the value of the "Username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m._Username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "Username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "Username" field.
func (m *UserMutation) ResetUsername() {
	m._Username = nil
}

// SetHash sets the "Hash" field.
func (m *UserMutation) SetHash(s string) {
	m._Hash = &s
}

// Hash returns the value of the "Hash" field in the mutation.
func (m *UserMutation) Hash() (r string, exists bool) {
	v := m._Hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "Hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "Hash" field.
func (m *UserMutation) ResetHash() {
	m._Hash = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._Username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m._Hash != nil {
		fields = append(fields, user.FieldHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldHash:
		return m.Hash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldHash:
		return m.OldHash(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldHash:
		m.ResetHash()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
