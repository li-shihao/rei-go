// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"rei.io/rei/ent/migrate"

	"rei.io/rei/ent/account"
	"rei.io/rei/ent/argument"
	"rei.io/rei/ent/event"
	"rei.io/rei/ent/nft"
	"rei.io/rei/ent/object"
	"rei.io/rei/ent/pkg"
	"rei.io/rei/ent/session"
	"rei.io/rei/ent/transaction"
	"rei.io/rei/ent/user"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Account is the client for interacting with the Account builders.
	Account *AccountClient
	// Argument is the client for interacting with the Argument builders.
	Argument *ArgumentClient
	// Event is the client for interacting with the Event builders.
	Event *EventClient
	// NFT is the client for interacting with the NFT builders.
	NFT *NFTClient
	// Object is the client for interacting with the Object builders.
	Object *ObjectClient
	// Pkg is the client for interacting with the Pkg builders.
	Pkg *PkgClient
	// Session is the client for interacting with the Session builders.
	Session *SessionClient
	// Transaction is the client for interacting with the Transaction builders.
	Transaction *TransactionClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// additional fields for node api
	tables tables
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Account = NewAccountClient(c.config)
	c.Argument = NewArgumentClient(c.config)
	c.Event = NewEventClient(c.config)
	c.NFT = NewNFTClient(c.config)
	c.Object = NewObjectClient(c.config)
	c.Pkg = NewPkgClient(c.config)
	c.Session = NewSessionClient(c.config)
	c.Transaction = NewTransactionClient(c.config)
	c.User = NewUserClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:         ctx,
		config:      cfg,
		Account:     NewAccountClient(cfg),
		Argument:    NewArgumentClient(cfg),
		Event:       NewEventClient(cfg),
		NFT:         NewNFTClient(cfg),
		Object:      NewObjectClient(cfg),
		Pkg:         NewPkgClient(cfg),
		Session:     NewSessionClient(cfg),
		Transaction: NewTransactionClient(cfg),
		User:        NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:         ctx,
		config:      cfg,
		Account:     NewAccountClient(cfg),
		Argument:    NewArgumentClient(cfg),
		Event:       NewEventClient(cfg),
		NFT:         NewNFTClient(cfg),
		Object:      NewObjectClient(cfg),
		Pkg:         NewPkgClient(cfg),
		Session:     NewSessionClient(cfg),
		Transaction: NewTransactionClient(cfg),
		User:        NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Account.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Account.Use(hooks...)
	c.Argument.Use(hooks...)
	c.Event.Use(hooks...)
	c.NFT.Use(hooks...)
	c.Object.Use(hooks...)
	c.Pkg.Use(hooks...)
	c.Session.Use(hooks...)
	c.Transaction.Use(hooks...)
	c.User.Use(hooks...)
}

// AccountClient is a client for the Account schema.
type AccountClient struct {
	config
}

// NewAccountClient returns a client for the Account from the given config.
func NewAccountClient(c config) *AccountClient {
	return &AccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `account.Hooks(f(g(h())))`.
func (c *AccountClient) Use(hooks ...Hook) {
	c.hooks.Account = append(c.hooks.Account, hooks...)
}

// Create returns a builder for creating a Account entity.
func (c *AccountClient) Create() *AccountCreate {
	mutation := newAccountMutation(c.config, OpCreate)
	return &AccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Account entities.
func (c *AccountClient) CreateBulk(builders ...*AccountCreate) *AccountCreateBulk {
	return &AccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Account.
func (c *AccountClient) Update() *AccountUpdate {
	mutation := newAccountMutation(c.config, OpUpdate)
	return &AccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccountClient) UpdateOne(a *Account) *AccountUpdateOne {
	mutation := newAccountMutation(c.config, OpUpdateOne, withAccount(a))
	return &AccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccountClient) UpdateOneID(id int) *AccountUpdateOne {
	mutation := newAccountMutation(c.config, OpUpdateOne, withAccountID(id))
	return &AccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Account.
func (c *AccountClient) Delete() *AccountDelete {
	mutation := newAccountMutation(c.config, OpDelete)
	return &AccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccountClient) DeleteOne(a *Account) *AccountDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *AccountClient) DeleteOneID(id int) *AccountDeleteOne {
	builder := c.Delete().Where(account.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccountDeleteOne{builder}
}

// Query returns a query builder for Account.
func (c *AccountClient) Query() *AccountQuery {
	return &AccountQuery{
		config: c.config,
	}
}

// Get returns a Account entity by its id.
func (c *AccountClient) Get(ctx context.Context, id int) (*Account, error) {
	return c.Query().Where(account.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccountClient) GetX(ctx context.Context, id int) *Account {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AccountClient) Hooks() []Hook {
	return c.hooks.Account
}

// ArgumentClient is a client for the Argument schema.
type ArgumentClient struct {
	config
}

// NewArgumentClient returns a client for the Argument from the given config.
func NewArgumentClient(c config) *ArgumentClient {
	return &ArgumentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `argument.Hooks(f(g(h())))`.
func (c *ArgumentClient) Use(hooks ...Hook) {
	c.hooks.Argument = append(c.hooks.Argument, hooks...)
}

// Create returns a builder for creating a Argument entity.
func (c *ArgumentClient) Create() *ArgumentCreate {
	mutation := newArgumentMutation(c.config, OpCreate)
	return &ArgumentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Argument entities.
func (c *ArgumentClient) CreateBulk(builders ...*ArgumentCreate) *ArgumentCreateBulk {
	return &ArgumentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Argument.
func (c *ArgumentClient) Update() *ArgumentUpdate {
	mutation := newArgumentMutation(c.config, OpUpdate)
	return &ArgumentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ArgumentClient) UpdateOne(a *Argument) *ArgumentUpdateOne {
	mutation := newArgumentMutation(c.config, OpUpdateOne, withArgument(a))
	return &ArgumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ArgumentClient) UpdateOneID(id int) *ArgumentUpdateOne {
	mutation := newArgumentMutation(c.config, OpUpdateOne, withArgumentID(id))
	return &ArgumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Argument.
func (c *ArgumentClient) Delete() *ArgumentDelete {
	mutation := newArgumentMutation(c.config, OpDelete)
	return &ArgumentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ArgumentClient) DeleteOne(a *Argument) *ArgumentDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *ArgumentClient) DeleteOneID(id int) *ArgumentDeleteOne {
	builder := c.Delete().Where(argument.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ArgumentDeleteOne{builder}
}

// Query returns a query builder for Argument.
func (c *ArgumentClient) Query() *ArgumentQuery {
	return &ArgumentQuery{
		config: c.config,
	}
}

// Get returns a Argument entity by its id.
func (c *ArgumentClient) Get(ctx context.Context, id int) (*Argument, error) {
	return c.Query().Where(argument.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ArgumentClient) GetX(ctx context.Context, id int) *Argument {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ArgumentClient) Hooks() []Hook {
	return c.hooks.Argument
}

// EventClient is a client for the Event schema.
type EventClient struct {
	config
}

// NewEventClient returns a client for the Event from the given config.
func NewEventClient(c config) *EventClient {
	return &EventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `event.Hooks(f(g(h())))`.
func (c *EventClient) Use(hooks ...Hook) {
	c.hooks.Event = append(c.hooks.Event, hooks...)
}

// Create returns a builder for creating a Event entity.
func (c *EventClient) Create() *EventCreate {
	mutation := newEventMutation(c.config, OpCreate)
	return &EventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Event entities.
func (c *EventClient) CreateBulk(builders ...*EventCreate) *EventCreateBulk {
	return &EventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Event.
func (c *EventClient) Update() *EventUpdate {
	mutation := newEventMutation(c.config, OpUpdate)
	return &EventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventClient) UpdateOne(e *Event) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEvent(e))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventClient) UpdateOneID(id int) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEventID(id))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Event.
func (c *EventClient) Delete() *EventDelete {
	mutation := newEventMutation(c.config, OpDelete)
	return &EventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventClient) DeleteOne(e *Event) *EventDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *EventClient) DeleteOneID(id int) *EventDeleteOne {
	builder := c.Delete().Where(event.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventDeleteOne{builder}
}

// Query returns a query builder for Event.
func (c *EventClient) Query() *EventQuery {
	return &EventQuery{
		config: c.config,
	}
}

// Get returns a Event entity by its id.
func (c *EventClient) Get(ctx context.Context, id int) (*Event, error) {
	return c.Query().Where(event.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventClient) GetX(ctx context.Context, id int) *Event {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EventClient) Hooks() []Hook {
	return c.hooks.Event
}

// NFTClient is a client for the NFT schema.
type NFTClient struct {
	config
}

// NewNFTClient returns a client for the NFT from the given config.
func NewNFTClient(c config) *NFTClient {
	return &NFTClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `nft.Hooks(f(g(h())))`.
func (c *NFTClient) Use(hooks ...Hook) {
	c.hooks.NFT = append(c.hooks.NFT, hooks...)
}

// Create returns a builder for creating a NFT entity.
func (c *NFTClient) Create() *NFTCreate {
	mutation := newNFTMutation(c.config, OpCreate)
	return &NFTCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NFT entities.
func (c *NFTClient) CreateBulk(builders ...*NFTCreate) *NFTCreateBulk {
	return &NFTCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NFT.
func (c *NFTClient) Update() *NFTUpdate {
	mutation := newNFTMutation(c.config, OpUpdate)
	return &NFTUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NFTClient) UpdateOne(n *NFT) *NFTUpdateOne {
	mutation := newNFTMutation(c.config, OpUpdateOne, withNFT(n))
	return &NFTUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NFTClient) UpdateOneID(id int) *NFTUpdateOne {
	mutation := newNFTMutation(c.config, OpUpdateOne, withNFTID(id))
	return &NFTUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NFT.
func (c *NFTClient) Delete() *NFTDelete {
	mutation := newNFTMutation(c.config, OpDelete)
	return &NFTDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NFTClient) DeleteOne(n *NFT) *NFTDeleteOne {
	return c.DeleteOneID(n.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *NFTClient) DeleteOneID(id int) *NFTDeleteOne {
	builder := c.Delete().Where(nft.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NFTDeleteOne{builder}
}

// Query returns a query builder for NFT.
func (c *NFTClient) Query() *NFTQuery {
	return &NFTQuery{
		config: c.config,
	}
}

// Get returns a NFT entity by its id.
func (c *NFTClient) Get(ctx context.Context, id int) (*NFT, error) {
	return c.Query().Where(nft.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NFTClient) GetX(ctx context.Context, id int) *NFT {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *NFTClient) Hooks() []Hook {
	return c.hooks.NFT
}

// ObjectClient is a client for the Object schema.
type ObjectClient struct {
	config
}

// NewObjectClient returns a client for the Object from the given config.
func NewObjectClient(c config) *ObjectClient {
	return &ObjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `object.Hooks(f(g(h())))`.
func (c *ObjectClient) Use(hooks ...Hook) {
	c.hooks.Object = append(c.hooks.Object, hooks...)
}

// Create returns a builder for creating a Object entity.
func (c *ObjectClient) Create() *ObjectCreate {
	mutation := newObjectMutation(c.config, OpCreate)
	return &ObjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Object entities.
func (c *ObjectClient) CreateBulk(builders ...*ObjectCreate) *ObjectCreateBulk {
	return &ObjectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Object.
func (c *ObjectClient) Update() *ObjectUpdate {
	mutation := newObjectMutation(c.config, OpUpdate)
	return &ObjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ObjectClient) UpdateOne(o *Object) *ObjectUpdateOne {
	mutation := newObjectMutation(c.config, OpUpdateOne, withObject(o))
	return &ObjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ObjectClient) UpdateOneID(id int) *ObjectUpdateOne {
	mutation := newObjectMutation(c.config, OpUpdateOne, withObjectID(id))
	return &ObjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Object.
func (c *ObjectClient) Delete() *ObjectDelete {
	mutation := newObjectMutation(c.config, OpDelete)
	return &ObjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ObjectClient) DeleteOne(o *Object) *ObjectDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *ObjectClient) DeleteOneID(id int) *ObjectDeleteOne {
	builder := c.Delete().Where(object.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ObjectDeleteOne{builder}
}

// Query returns a query builder for Object.
func (c *ObjectClient) Query() *ObjectQuery {
	return &ObjectQuery{
		config: c.config,
	}
}

// Get returns a Object entity by its id.
func (c *ObjectClient) Get(ctx context.Context, id int) (*Object, error) {
	return c.Query().Where(object.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ObjectClient) GetX(ctx context.Context, id int) *Object {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ObjectClient) Hooks() []Hook {
	return c.hooks.Object
}

// PkgClient is a client for the Pkg schema.
type PkgClient struct {
	config
}

// NewPkgClient returns a client for the Pkg from the given config.
func NewPkgClient(c config) *PkgClient {
	return &PkgClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pkg.Hooks(f(g(h())))`.
func (c *PkgClient) Use(hooks ...Hook) {
	c.hooks.Pkg = append(c.hooks.Pkg, hooks...)
}

// Create returns a builder for creating a Pkg entity.
func (c *PkgClient) Create() *PkgCreate {
	mutation := newPkgMutation(c.config, OpCreate)
	return &PkgCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Pkg entities.
func (c *PkgClient) CreateBulk(builders ...*PkgCreate) *PkgCreateBulk {
	return &PkgCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Pkg.
func (c *PkgClient) Update() *PkgUpdate {
	mutation := newPkgMutation(c.config, OpUpdate)
	return &PkgUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PkgClient) UpdateOne(pk *Pkg) *PkgUpdateOne {
	mutation := newPkgMutation(c.config, OpUpdateOne, withPkg(pk))
	return &PkgUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PkgClient) UpdateOneID(id int) *PkgUpdateOne {
	mutation := newPkgMutation(c.config, OpUpdateOne, withPkgID(id))
	return &PkgUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Pkg.
func (c *PkgClient) Delete() *PkgDelete {
	mutation := newPkgMutation(c.config, OpDelete)
	return &PkgDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PkgClient) DeleteOne(pk *Pkg) *PkgDeleteOne {
	return c.DeleteOneID(pk.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *PkgClient) DeleteOneID(id int) *PkgDeleteOne {
	builder := c.Delete().Where(pkg.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PkgDeleteOne{builder}
}

// Query returns a query builder for Pkg.
func (c *PkgClient) Query() *PkgQuery {
	return &PkgQuery{
		config: c.config,
	}
}

// Get returns a Pkg entity by its id.
func (c *PkgClient) Get(ctx context.Context, id int) (*Pkg, error) {
	return c.Query().Where(pkg.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PkgClient) GetX(ctx context.Context, id int) *Pkg {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PkgClient) Hooks() []Hook {
	return c.hooks.Pkg
}

// SessionClient is a client for the Session schema.
type SessionClient struct {
	config
}

// NewSessionClient returns a client for the Session from the given config.
func NewSessionClient(c config) *SessionClient {
	return &SessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `session.Hooks(f(g(h())))`.
func (c *SessionClient) Use(hooks ...Hook) {
	c.hooks.Session = append(c.hooks.Session, hooks...)
}

// Create returns a builder for creating a Session entity.
func (c *SessionClient) Create() *SessionCreate {
	mutation := newSessionMutation(c.config, OpCreate)
	return &SessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Session entities.
func (c *SessionClient) CreateBulk(builders ...*SessionCreate) *SessionCreateBulk {
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Session.
func (c *SessionClient) Update() *SessionUpdate {
	mutation := newSessionMutation(c.config, OpUpdate)
	return &SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SessionClient) UpdateOne(s *Session) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSession(s))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SessionClient) UpdateOneID(id int) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSessionID(id))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Session.
func (c *SessionClient) Delete() *SessionDelete {
	mutation := newSessionMutation(c.config, OpDelete)
	return &SessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SessionClient) DeleteOne(s *Session) *SessionDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *SessionClient) DeleteOneID(id int) *SessionDeleteOne {
	builder := c.Delete().Where(session.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SessionDeleteOne{builder}
}

// Query returns a query builder for Session.
func (c *SessionClient) Query() *SessionQuery {
	return &SessionQuery{
		config: c.config,
	}
}

// Get returns a Session entity by its id.
func (c *SessionClient) Get(ctx context.Context, id int) (*Session, error) {
	return c.Query().Where(session.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SessionClient) GetX(ctx context.Context, id int) *Session {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SessionClient) Hooks() []Hook {
	return c.hooks.Session
}

// TransactionClient is a client for the Transaction schema.
type TransactionClient struct {
	config
}

// NewTransactionClient returns a client for the Transaction from the given config.
func NewTransactionClient(c config) *TransactionClient {
	return &TransactionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `transaction.Hooks(f(g(h())))`.
func (c *TransactionClient) Use(hooks ...Hook) {
	c.hooks.Transaction = append(c.hooks.Transaction, hooks...)
}

// Create returns a builder for creating a Transaction entity.
func (c *TransactionClient) Create() *TransactionCreate {
	mutation := newTransactionMutation(c.config, OpCreate)
	return &TransactionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Transaction entities.
func (c *TransactionClient) CreateBulk(builders ...*TransactionCreate) *TransactionCreateBulk {
	return &TransactionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Transaction.
func (c *TransactionClient) Update() *TransactionUpdate {
	mutation := newTransactionMutation(c.config, OpUpdate)
	return &TransactionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TransactionClient) UpdateOne(t *Transaction) *TransactionUpdateOne {
	mutation := newTransactionMutation(c.config, OpUpdateOne, withTransaction(t))
	return &TransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TransactionClient) UpdateOneID(id int) *TransactionUpdateOne {
	mutation := newTransactionMutation(c.config, OpUpdateOne, withTransactionID(id))
	return &TransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Transaction.
func (c *TransactionClient) Delete() *TransactionDelete {
	mutation := newTransactionMutation(c.config, OpDelete)
	return &TransactionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TransactionClient) DeleteOne(t *Transaction) *TransactionDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *TransactionClient) DeleteOneID(id int) *TransactionDeleteOne {
	builder := c.Delete().Where(transaction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TransactionDeleteOne{builder}
}

// Query returns a query builder for Transaction.
func (c *TransactionClient) Query() *TransactionQuery {
	return &TransactionQuery{
		config: c.config,
	}
}

// Get returns a Transaction entity by its id.
func (c *TransactionClient) Get(ctx context.Context, id int) (*Transaction, error) {
	return c.Query().Where(transaction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TransactionClient) GetX(ctx context.Context, id int) *Transaction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TransactionClient) Hooks() []Hook {
	return c.hooks.Transaction
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}
